# C++ 常见问题(补充)

## C++基础

### 变量和基本类型

- C++ 中的基本数据类型有哪些？它们的存储大小是多少？

- C++ 中的 sizeof 运算符有什么作用？如何使用它？

- C++ 中的逻辑运算符有哪些？它们的优先级是怎样的？

- 什么是 const 关键字？它在 C++ 中有哪些应用？

- 什么是结构体？C++ 中如何声明和使用结构体？

- 什么是枚举类型？C++ 中如何声明和使用枚举类型？

- 指针和引用有什么区别？

### 字符串、向量和数组

- 字符串

	- 如何在一个字符串中查找一个子串？

	- 如何删除字符串中的空格？

	- 如何将一个字符串转换为整数？

- 数组

	- 如何实现数组的二分查找算法？

	- 如何对数组进行排序？

- 向量

	- 数组和vector有什么区别？

	- 数组和vector各项操作时间复杂度是多少？

### 语句

- 如何在C++中使用switch语句，它与if语句有什么区别？

- 请解释一下C++中的goto语句，它的用法和语法。

- 请解释一下C++中的continue和break语句，在什么情况下使用它们？

### 函数

- 什么是函数重载？如何实现函数重载？

- 什么是默认参数？如何使用默认参数？

- 什么是引用参数？为什么要使用引用参数？

- 什么是指针参数？如何使用指针参数？

- 什么是内联函数？如何使用内联函数？

- 什么是函数指针？如何使用函数指针？

- 什么是Lambda表达式？如何使用Lambda表达式？

### 类基础

- 什么是构造函数和析构函数？它们的作用是什么？

- 什么是拷贝构造函数？为什么需要它？

- 什么是成员函数和成员变量？

- 什么是虚函数？它的作用是什么？

- 什么是纯虚函数？它的作用是什么？

- 什么是const成员函数？为什么需要它？

- 什么是友元函数和友元类？

- 什么是静态成员变量和静态成员函数？

## 其他

### string和char数组有什么区别？什么时候应该使用哪个？

### C++标准库中的算法有哪些？它们可以用于哪些容器？

### C++标准库中的智能指针有哪些？它们的作用是什么？

### C++标准库中的异常处理机制是什么？它们是如何工作的？

### C++标准库中的文件流有哪些？如何读取和写入文件？

### C++11 标准库：什么是 C++11 标准库？C++11 标准库中有哪些新增的容器？C++11 标准库中有哪些新增的算法？C++11 标准库中有哪些新增的线程和同步原语？

### 并发编程：什么是并发编程？为什么需要并发编程？如何使用 C++11 中的 std::thread、std::mutex、std::condition_variable 实现并发编程？

## C++面向对象

### 拷贝控制

- 什么是移动构造函数和移动赋值运算符？

- 什么是拷贝构造函数？

- 什么是赋值运算符？

- 什么是默认构造函数？

- 什么时候会调用拷贝构造函数？

- 什么时候会调用赋值运算符？

- 如何实现深拷贝和浅拷贝？

- 什么是 RAII（Resource Acquisition Is Initialization）技术，如何使用它来管理资源？

- 什么是智能指针？如何防止内存泄漏？

- 如何禁止类的对象进行复制操作？

### 重载运算与类型转换

- 什么是运算符重载？

- 如何重载运算符？

- 重载哪些运算符是合法的？

- 什么是隐式类型转换？

- 如何防止意外的隐式类型转换？

- 运算符重载和类型转换有什么限制？

### 面向对象程序设计

- 什么是多重继承？它有什么优点和缺点？

- 什么是虚继承？它有什么优点和缺点？

- 什么是右值引用？如何使用右值引用？

- 什么是移动构造函数？为什么需要移动构造函数？

- 什么是抽象类？如何定义抽象类？

- 什么是虚函数？为什么需要虚函数？

- 什么是纯虚函数？为什么需要纯虚函数？

### 模板与泛型编程

- 什么是C++模板？你能给一个例子吗？

- 什么是函数模板？如何使用函数模板？

- 什么是模板类？它有什么作用？

- 什么是模板偏特化（Template Partial Specialization）？它有什么作用？

- 什么是类型推导（Type Deduction）？C++11引入了哪些类型推导方法？

## C++标准库

### IO库

- 如何在 C++ 中读取文件？如何将读取的内容写入到文件中？

- 解释 C++ 中的缓冲区是什么，以及为什么要使用缓冲区？

- 如何将 C++ 标准输出重定向到文件中？

### 顺序容器

- vector 和 array 有什么区别？

	- 大小灵活性

		- array是一个静态数组，他大小在声明时就被确定，并在整个生命周期保持不变；vector是一个动态数组，可以在声明的时候不需要确定大小，可以在运行时动态的增删元素

	- 内存管理

		- array在栈上或者全局数据区里分配内存，大小在编译时确定；vector在堆上动态分配、管理内存，也需要额外的内存管理开销。

	- 初始化和赋值

		- array可以使用初始化列表进行初始化；vector可以在声明的时候为空，然后用push_back或者初始化列表添加元素

	- 访问方式

		- 支持随机访问

	- 传递给函数的方式

		- 在将array传递给函数的时候，需要指定大小；传vector的时候，不需要

- 如何在 vector 和 deque 中快速插入和删除元素？

	- push_back(), deque也支持push_front()

- list 和 vector 的区别是什么？它们适用于不同的场景吗？

	- 区别

		- 底层数据结构：

			- vector 使用动态数组作为底层数据结构，元素在内存中是连续存储的。

			- list 使用双向链表作为底层数据结构，元素在内存中不一定是连续存储的。

		- 元素的存储和访问：

			- vector 支持通过下标直接访问元素，因为元素在内存中是连续存储的，因此随机访问的效率较高。

			- list 不支持通过下标直接访问元素，必须通过迭代器进行顺序访问。在链表中，随机访问的效率较低。

		- 插入和删除操作：

			- vector 在尾部进行插入和删除操作的效率很高，但在中间或头部插入或删除元素可能涉及到大量的数据移动。

			- list 在任意位置进行插入和删除操作的效率都相对较高，因为只需调整节点的指针。

		- 内存占用：

			- vector 的内存占用相对较小，因为它只存储元素值，不需要额外的指针和节点。

			- list 的内存占用相对较大，因为每个元素都需要额外的指针来指向前一个和后一个元素。

		- 迭代器失效：

			- 在 vector 中，如果在插入或删除操作后获取到迭代器，之前的迭代器可能会失效，因为元素的内存地址可能发生变化。

			- 在 list 中，由于元素在链表中，迭代器在插入或删除操作后依然有效，不会失效

- 如何在 vector 中实现自动扩容？

	- 如果当前容器的容量已经达到capacity,vector会自动分配一个更大的内存块，并且将原有元素拷贝到新的内存块里。resize 主要用于调整容器的大小，而 reserve 主要用于预留足够的内存空间，以避免频繁的动态内存分配操作，从而提高性能。

- 如何在 vector 中实现元素去重？

	- 首先，对 std::vector 进行排序，然后使用 std::unique 函数删除相邻的重复元素。
std::unique 并不实际删除重复的元素，而是将它们移到容器的末尾，并返回一个指向新末尾的迭代器，最后使用 erase 函数删除重复元素后的部分。

- vector 和 list 中的迭代器有什么区别？

- 如何使用 vector 实现栈和队列？

	- 栈是First in last out，队列是First in first out

- 顺序容器的类型有哪些？

	- stack, queue, list, forward list, deque, priority queue, vector, array

### 泛型算法

- 给定一个容器，如何使用泛型算法对容器进行排序？

	- std::sort 接受两个迭代器参数，即容器的起始迭代器和结束迭代器，它会对这个范围内的元素进行升序排序。对于其他容器类型，也可以使用相同的方式进行排序。

如果想进行自定义排序，可以传递一个比较函数或者使用 C++11 及更新版本的标准，可以使用 Lambda 表达式。如：std::sort(myVector.begin(), myVector.end(), [](int a, int b) {
        return a > b; // 降序排序
    });

- 什么情况下会发生迭代器失效？

	- 插入或删除元素： 在使用插入或删除操作修改容器的同时，原先的迭代器可能会失效。这是因为插入或删除元素可能导致容器的重新分配内存，从而改变元素的存储位置。
使用 erase 函数： 使用 erase 函数删除容器中的元素时，要特别小心。erase 函数返回指向下一个元素的迭代器，因此在使用 erase 后，之前的迭代器可能会失效。
在 vector 中的动态数组扩容： 在使用 std::vector 时，当元素的数量超过当前容器的容量，vector 可能会重新分配内存并将元素复制到新的内存位置。这会导致之前的迭代器失效。
在 deque 的两端进行插入或删除操作： 在 std::deque 中，在两端进行插入或删除操作时，可能导致迭代器失效。deque 使用多个块来存储元素，可能需要移动元素或重新分配内存。
在 list 中的插入或删除操作： 在 std::list 中，由于它是双向链表，插入或删除元素通常不会使迭代器失效，但要注意迭代器可能会指向被删除的元素，需要小心处理。

- 给定一个容器，如何使用泛型算法查找容器中的最大/最小值？

	- 可以使用max_element/min_element，或者自定义一个比较函数

### 关联容器

- 什么是C++关联容器？有哪些常见的关联容器？

	- 关联容器的英文是 "Associative Containers"。在 C++ STL 中，关联容器是一类具有关联关系的容器，其中的元素通常以键-值对（key-value pair）的形式存储，且按照键的顺序组织。关联容器的一些常见类型包括 std::map、std::set、std::multimap、std::multiset 等。这些容器提供了在键和值之间建立映射关系的功能。

- unordered_map和map有什么区别？

	- 有序性：
std::map（ordered_map）： 保持元素的插入顺序，即元素按照键的升序排列。
std::unordered_map： 不保持元素的插入顺序，元素的存储顺序与键的哈希值有关，可以认为是无序的。
底层实现：
std::map（ordered_map）： 基于红黑树（Red-Black Tree）实现，保证了元素的有序性。
std::unordered_map： 基于哈希表（Hash Table）实现，使用哈希函数来快速定位元素，不关心元素的插入顺序。
性能：
std::map（ordered_map）： 查找、插入和删除的平均时间复杂度为 O(log n)，其中 n 是元素的数量。
std::unordered_map： 查找、插入和删除的平均时间复杂度为 O(1)，在理想情况下是常数时间，但具体性能可能受到哈希冲突的影响。
哈希函数：
std::map（ordered_map）： 不需要哈希函数，直接根据元素的键进行有序存储。
std::unordered_map： 需要提供一个哈希函数，以确保元素能够均匀分布在哈希表中，减小哈希冲突的概率。

- 什么情况下应该使用map，什么情况下应该使用unordered_map？

	- 使用 std::map（或 std::ordered_map）的情况：

有序性要求： 如果你需要保持元素的插入顺序或按照键的顺序进行有序存储，应该选择 std::map 或 std::ordered_map。
不需要自定义哈希函数： std::map 不需要提供自定义的哈希函数，而是使用元素的比较运算符来进行有序存储。
相对较小的数据量： 在数据量相对较小的情况下，std::map 可能在性能上具有更好的表现，因为它不需要处理哈希冲突。
使用 std::unordered_map 的情况：

无序性要求： 如果对元素的插入顺序不关心，只关心快速的查找、插入和删除操作，可以选择 std::unordered_map。
自定义哈希函数： 如果你需要自定义哈希函数以适应特定的键类型，应该选择 std::unordered_map。
大数据量： 在数据量较大的情况下，std::unordered_map 可能在平均性能上更优，因为哈希表的查找操作具有较低的时间复杂度。

- C++关联容器中的元素是如何排序的？

	- 按照键来排序

- 关联容器中的迭代器和指针有什么区别？

- 如何在C++关联容器中使用自定义比较函数进行排序？

	- struct CustomCompare {
    // 比较函数接受两个参数，返回值为布尔类型
    bool operator()(const int& a, const int& b) const {
        // 这里定义比较规则，可以根据需要修改
        return a > b;  // 降序排序
    }
};

### 动态内存

- 什么是智能指针？它们是如何工作的？
什么是数组和指针之间的区别？如何动态分配数组？
什么是虚拟析构函数？为什么需要它？
如何在 C++ 中处理异常情况，如内存分配失败？

	- 智能指针通过封装原始指针，并在对象销毁时自动释放分配的内存。最常见的智能指针有 std::shared_ptr 和 std::unique_ptr。

std::shared_ptr： 允许多个指针共享同一块内存，使用引用计数来跟踪共享的次数。当引用计数为零时，内存被释放。
std::unique_ptr： 独占所有权的指针，只能有一个指针指向分配的内存。当 std::unique_ptr 离开作用域时，它拥有的内存会被释放。

	- int* dynamicArray = new int[5];
// 返回的是指向数组首元素的指针
delete[] dynamicArray;  // 释放动态分配的数组内存

	- 在 C++ 中，异常处理使用 try、catch 和 throw 关键字。
try {
    // 可能抛出异常的代码
    // ...
}
catch (Type1 ex1) {
    // 处理 Type1 类型的异常
    // ...
}
catch (Type2 ex2) {
    // 处理 Type2 类型的异常
    // ...
}
catch (...) {
    // 捕获其他类型的异常
    // ...
}
如果 new 操作符导致内存分配失败，会抛出 std::bad_alloc 异常，然后被 catch 块捕获。在 catch 块中，可以执行处理内存分配失败的操作。

	- 什么是虚拟析构函数？
虚拟析构函数是一个在基类中声明为虚函数的析构函数。它在继承体系中的派生类对象被删除时，确保调用正确的析构函数，从而避免切片问题。

为什么需要虚拟析构函数？
当使用基类指针指向派生类对象时，如果派生类对象被删除，但基类的析构函数不是虚函数，那么只会调用基类的析构函数，而不会调用派生类的析构函数，导致资源泄漏。通过将基类的析构函数声明为虚函数，可以确保在删除派生类对象时调用正确的析构函数。

- 什么是动态内存分配？如何在 C++ 中进行动态内存分配？

	- 动态内存分配通常用于创建动态大小的数组、动态构造对象以及在需要时动态分配和释放内存

- C++ 中的 new 和 malloc 有什么区别？

	- 类型信息：
new： new 是类型感知的。它为特定类型的对象分配内存并调用该类型的构造函数。
malloc： malloc 不是类型感知的。它分配指定大小的内存块，不调用任何构造函数，将内存视为原始字节。
初始化：
new： new 不仅分配内存，还通过调用对象的构造函数对内存进行初始化。
malloc： malloc 分配未初始化的内存。你需要手动初始化内存。
返回类型：
new： 返回指向指定类型内存的指针。
malloc： 返回 void*，需要强制类型转换为所需的类型。
指定大小：
new： 自动计算类型的大小。
malloc： 需要显式指定以字节为单位的大小。
异常处理：
new： 如果分配失败，会抛出 std::bad_alloc 异常。
malloc： 如果分配失败，返回一个空指针。
兼容性：
new： 是C++的一部分，支持运算符重载等用于自定义内存管理的特性。
malloc： 是C标准库的一部分，不是C++特有的。

- 什么是内存泄漏？如何避免内存泄漏？

	- 内存泄漏是指在程序运行期间，程序分配的内存未能被释放，导致系统中的可用内存减少。内存泄漏可能导致程序消耗大量内存，最终导致程序性能下降，甚至崩溃。

	- 如何避免内存泄漏？

- 什么是动态多态性？如何在 C++ 中实现动态多态性？

	- 在继承关系中，基类定义一个虚函数（virtual function）。
派生类可以重写（override）这个虚函数，提供特定于派生类的实现。
在运行时，通过基类指针或引用调用虚函数时，系统会根据实际对象的类型来确定调用哪个版本的虚函数。

- 如何在 C++ 中删除动态分配的内存？

	- 在 C++ 中，你可以使用 `delete` 操作符来删除动态分配的内存。这通常用于释放使用 `new` 操作符分配的单个对象或使用 `new[]` 操作符分配的数组。

注意事项：
- 使用 `delete` 操作符释放动态分配的内存，确保在不再需要该内存时进行释放，以避免内存泄漏。
- 使用 `delete[]` 操作符释放动态分配的数组，而不是简单的 `delete`，以确保释放整个数组。
- 在释放内存后，将指针设置为 `nullptr`，以避免悬空指针。

**注意：** 在现代 C++ 中，更推荐使用智能指针（`std::unique_ptr` 或 `std::shared_ptr`）来管理动态分配的内存，以减少手动内存管理带来的潜在问题。智能指针在对象生命周期结束时自动释放内存，有助于避免内存泄漏和悬空指针。

