---
weight: 4
title: "C++STL知识点"
date: 2024-5-20T21:57:40+08:00
lastmod: 2024-5-20T16:45:40+08:00
draft: false
author: "Jiawen Liu"
authorLink: "https://jiawenliu0901.github.io"
description: "C++"
tags: ["C++"]
categories: ["C++八股"]
lightgallery: true
---
# C++标准库
## IO库
### 如何在 C++ 中读取文件？如何将读取的内容写入到文件中？
### 解释 C++ 中的缓冲区是什么，以及为什么要使用缓冲区？
### 如何将 C++ 标准输出重定向到文件中？
## 顺序容器
### vector 和 array 有什么区别？
### 如何在 vector 和 deque 中快速插入和删除元素？
### list 和 vector 的区别是什么？它们适用于不同的场景吗？
### 如何在 vector 中实现自动扩容？
### 如何在 vector 中实现元素去重？
### vector 和 list 中的迭代器有什么区别？
### 如何使用 vector 实现栈和队列？
### 顺序容器的类型有哪些？
## 泛型算法
### 给定一个容器，如何使用泛型算法对容器进行排序？
### 什么情况下会发生迭代器失效？
### 给定一个容器，如何使用泛型算法查找容器中的最大/最小值？
## 关联容器
### 什么是C++关联容器？有哪些常见的关联容器？
### unordered_map和map有什么区别？
### 什么情况下应该使用map，什么情况下应该使用unordered_map？
### C++关联容器中的元素是如何排序的？
### 关联容器中的迭代器和指针有什么区别？
### 如何在C++关联容器中使用自定义比较函数进行排序？

## 动态内存
### 什么是数组和指针之间的区别？如何动态分配数组？

### 什么是虚拟析构函数？为什么需要它？
虚拟析构函数是在基类中声明为虚函数的析构函数。它的主要目的是确保当通过基类指针删除派生类对象时,派生类的析构函数能够被正确调用,从而避免内存泄漏和未定义行为。

在C++中,当使用基类指针指向派生类对象,并通过该指针删除对象时,如果基类的析构函数不是虚函数,那么只会调用基类的析构函数,而不会调用派生类的析构函数。这可能导致派生类中分配的资源没有被正确释放,引发内存泄漏和其他问题。

下面是一个简单的示例,说明为什么需要虚拟析构函数:

```cpp
class Base {
public:
    Base() { std::cout << "Base constructor" << std::endl; }
    ~Base() { std::cout << "Base destructor" << std::endl; }
};

class Derived : public Base {
public:
    Derived() { std::cout << "Derived constructor" << std::endl; }
    ~Derived() { std::cout << "Derived destructor" << std::endl; }
};

int main() {
    Base* obj = new Derived();
    delete obj;
    return 0;
}
```

输出结果:
```
Base constructor
Derived constructor
Base destructor
```

在这个示例中,我们通过基类指针`Base*`创建了一个派生类`Derived`的对象,并使用`delete`操作符删除该对象。然而,由于基类`Base`的析构函数不是虚函数,所以只调用了基类的析构函数,而没有调用派生类的析构函数。这意味着派生类中可能分配的资源没有被正确释放。

为了解决这个问题,我们需要将基类的析构函数声明为虚函数:

```cpp
class Base {
public:
    Base() { std::cout << "Base constructor" << std::endl; }
    virtual ~Base() { std::cout << "Base destructor" << std::endl; }
};
```

现在,当通过基类指针删除派生类对象时,会先调用派生类的析构函数,然后再调用基类的析构函数,确保派生类中的资源被正确释放。

输出结果:
```
Base constructor
Derived constructor
Derived destructor
Base destructor
```

总结:
- 虚拟析构函数确保在通过基类指针删除派生类对象时,派生类的析构函数能够被正确调用。
- 如果基类的析构函数不是虚函数,那么删除派生类对象时只会调用基类的析构函数,而不会调用派生类的析构函数,可能导致内存泄漏和未定义行为。
- 将基类的析构函数声明为虚函数,可以确保在删除派生类对象时,先调用派生类的析构函数,然后再调用基类的析构函数,确保资源的正确释放。

建议在设计基类时,如果预计会有派生类继承自该基类,并且派生类有自己的资源需要释放,就应该将基类的析构函数声明为虚函数。这是一个良好的编程实践,可以防止内存泄漏和未定义行为。

### 如何在 C++ 中处理异常情况，如内存分配失败？

https://blog.csdn.net/sailorlyq/article/details/79101399

### 什么是动态内存分配？如何在 C++ 中进行动态内存分配？

静态内存分配：在编译阶段就分配好存储单元空间，在程序运行过程中，这些空间的大小是不可更改的，也无需对这些空间进行管理，编译时已将管理这些空间的代码加入目标程序，在作用域结束之后，自动将空间归还给系统。
动态分配空间： 指在程序语句中通过内存分配函数或者内存分配运算符取得的存储空间，这样得到的空间的大小，编译器是不知道的，完全由动态运行中的程序的当时的情况来决定；这些空间在使用完毕后，必须由程序语句显示的将其释放归还系统，否则会使得系统分配和利用的内存空间不断减少，直至枯竭，导致系统无法工作。
动态分配和释放内存有两种方法：一是利用标准函数，如malloc和free，它们的原型在头文件stdlib.h或alloc.h中，这是从C语言中保留下来的方法；另外一种是用new和delete运算符，这是C++的方法。
                        
原文链接：https://blog.csdn.net/weixin_60479183/article/details/128371404

### C++ 中的 new 和 malloc 有什么区别？
下面是一个表格,展示了C++中`new`和`malloc`的区别:

| 特性 | new | malloc |
|---|---|---|
| 分配内存的位置 | 在自由存储区(堆)上分配内存 | 在堆上分配内存 |
| 返回值类型 | 返回指定类型的指针 | 返回`void*`类型的指针,需要显式类型转换 |
| 分配失败的处理 | 抛出`std::bad_alloc`异常 | 返回`nullptr` |
| 内存大小的计算 | 根据类型自动计算所需内存大小 | 需要手动计算并传递内存大小 |
| 构造函数的调用 | 在分配内存后自动调用类型的构造函数 | 不会调用构造函数,需要手动初始化内存 |
| 析构函数的调用 | 在释放内存前自动调用类型的析构函数 | 不会调用析构函数,需要手动释放内存 |
| 操作符重载 | 可以重载`new`和`delete`操作符 | 不能重载`malloc`和`free`函数 |
| 类型安全 | 具有类型安全性,返回指定类型的指针 | 没有类型安全性,需要手动进行类型转换 |
| 与C语言的兼容性 | C++特有的内存分配方式 | 与C语言兼容的内存分配方式 |

从上表可以看出,`new`和`malloc`在内存分配和管理方面有以下主要区别:

1. `new`返回指定类型的指针,而`malloc`返回`void*`类型的指针,需要显式进行类型转换。

2. `new`在分配内存失败时会抛出`std::bad_alloc`异常,而`malloc`返回`nullptr`。

3. `new`根据类型自动计算所需内存大小,而`malloc`需要手动计算并传递内存大小。

4. `new`在分配内存后自动调用类型的构造函数,而`malloc`不会调用构造函数,需要手动初始化内存。

5. `new`在释放内存前自动调用类型的析构函数,而`malloc`不会调用析构函数,需要手动释放内存。

6. `new`和`delete`操作符可以被重载,而`malloc`和`free`函数不能被重载。

7. `new`具有类型安全性,返回指定类型的指针,而`malloc`没有类型安全性,需要手动进行类型转换。

8. `new`是C++特有的内存分配方式,而`malloc`与C语言兼容。

在C++中,推荐使用`new`和`delete`进行动态内存分配和释放,因为它们提供了类型安全性、构造函数和析构函数的自动调用,以及异常处理等优势。而`malloc`和`free`函数主要用于与C语言的兼容性,或者在某些特殊情况下需要手动管理内存的场景。

### 什么是内存泄漏？如何避免内存泄漏？

1. 内存溢出
内存溢出 OOM （out of memory），是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory；比如申请了一个int,但给它存了long才能存下的数，那就是内存溢出。

2. 内存泄漏
内存泄露 memory leak，是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。最终的结果就是导致OOM。

内存泄漏是指你向系统申请分配内存进行使用(new)，可是使用完了以后却不归还(delete)，结果你申请到的那块内存你自己也不能再访问（也许你把它的地址给弄丢了），而系统也不能再次将它分配给需要的程序。

3. 造成内存泄露常见的三种情况
1，指针重新赋值

2，错误的内存释放

3，返回值的不正确处理

3.1 指针重新赋值

如下代码：

char * p = (char *)malloc(10);
char * np = (char *)malloc(10);
其中，指针变量 p 和 np 分别被分配了 10 个字节的内存。

如果程序需要执行如下赋值语句：

p=np;

这时候，指针变量 p 被 np 指针重新赋值，其结果是 p 以前所指向的内存位置变成了孤立的内存。它无法释放，因为没有指向该位置的引用，从而导致 10 字节的内存泄漏。

因此，在对指针赋值前，一定确保内存位置不会变为孤立的。

类似的情况，连续重复new的情况也是类似：

int *p = new int; 
p = new int...;//错误

3.2 错误的内存释放

假设有一个指针变量 p，它指向一个 10 字节的内存位置。该内存位置的第三个字节又指向某个动态分配的 10 字节的内存位置。

如果程序需要执行如下赋值语句时：

free(p);
很显然，如果通过调用 free 来释放指针 p，则 np 指针也会因此而变得无效。np 以前所指向的内存位置也无法释放，因为已经没有指向该位置的指针。换句话说，np 所指向的内存位置变为孤立的，从而导致内存泄漏。

因此，每当释放结构化的元素，而该元素又包含指向动态分配的内存位置的指针时，应首先遍历子内存位置（如本示例中的 np），并从那里开始释放，然后再遍历回父节点，如下面的代码所示：

free(p->np);
free(p);

3.3 返回值的不正确处理

有时候，某些函数会返回对动态分配的内存的引用，如下面的示例代码所示：

char *f(){
	return (char *)malloc(10);
}
void f1(){
	f();
}
函数 f1 中对 f 函数的调用并未处理该内存位置的返回地址，其结果将导致 f 函数所分配的 10 个字节的块丢失，并导致内存泄漏。

4 在内存分配后忘记使用 free 进行释放

如何避免内存泄漏？

确保没有在访问空指针。
每个内存分配函数都应该有一个 free 函数与之对应，alloca 函数除外。
每次分配内存之后都应该及时进行初始化，可以结合 memset 函数进行初始化，calloc 函数除外。
每当向指针写入值时，都要确保对可用字节数和所写入的字节数进行交叉核对。
在对指针赋值前，一定要确保没有内存位置会变为孤立的。
每当释放结构化的元素（而该元素又包含指向动态分配的内存位置的指针）时，都应先遍历子内存位置并从那里开始释放，然后再遍历回父节点。
始终正确处理返回动态分配的内存引用的函数返回值。

### 如何行为内存泄漏？

https://zhuanlan.zhihu.com/p/458541056

### 什么是动态多态性？如何在 C++ 中实现动态多态性？（dynamic polymorphism）？动态多态性和静态多态性的区别？
多态（Polymorphisn）是面向对象程序设计（OOP）的一个重要特征。多态字面意思为多种状态。在面向对象语言中，一个接口，多种实现即为多态。C++中的多态性具体体现在编译和运行两个阶段。编译时多态是静态多态，在编译时就可以确定使用的接口。运行时多态是动态多态，具体引用的接口在运行时才能确定。

静态多态和动态多态的区别其实只是在什么时候将函数实现和函数调用关联起来，是在编译时期还是运行时期，即函数地址是早绑定还是晚绑定的。静态多态是指在编译期间就可以确定函数的调用地址，并生产代码，这就是静态的，也就是说地址是早绑定。静态多态往往也被叫做静态联编。动态多态则是指函数调用的地址不能在编译器期间确定，需要在运行时确定，属于晚绑定，动态多态往往也被叫做动态联编。

为何要使用多态呢？封装可以使得代码模块化，继承可以扩展已存在的代码，他们的目的都是为了代码重用。而多态的目的则是为了接口重用。静态多态，将同一个接口进行不同的实现，根据传入不同的参数（个数或类型不同）调用不同的实现。动态多态，则不论传递过来的哪个类的对象，函数都能够通过同一个接口调用到各自对象实现的方法。

通过上面的例子可以看出，在使用基类指针或引用指向子类对象时，调用的函数是子类中重写的函数，这样就实现了运行时函数地址的动态绑定，即动态联编。动态多态是通过“继承+虚函数”来实现的，只有在程序运行期间（非编译期）才能判断所引用对象的实际类型，根据其实际类型调用相应的方法。具体格式就是使用virtual关键字修饰类的成员函数时，指明该函数为虚函数，并且派生类需要重新实现该成员函数，编译器将实现动态绑定。

**总结**：
应用形式上：
静态多态是发散式的，让相同的实现代码应用于不同的场合。动态多态是收敛式的，让不同的实现代码应用于相同的场合。
思维方式上：
静态多态是泛型式编程风格，它看重的是算法的普适性。动态多态是对象式编程风格，它看重的是接口和实现的分离度。
————————————————                      
原文链接：https://blog.csdn.net/helloqusheng/article/details/133100991

### 如何在 C++ 中删除动态分配的内存？
delete 或者delete[]


