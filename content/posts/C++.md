---
weight: 4
title: "C++知识点整理总结"
date: 2023-03-20T21:57:40+08:00
lastmod: 2023-03-20T16:45:40+08:00
draft: false
author: "Jiawen Liu"
authorLink: "https://jiawenliu0901.github.io"
description: "C++知识点整理总结"
tags: ["C++"]
categories: ["C++八股"]
lightgallery: true
---
# C++ 常见问题(补充)

## C++基础

### 变量和基本类型

- C++ 中的基本数据类型有哪些？它们的存储大小是多少？

	- 整数类型（Integer Types）：
bool： 用于存储布尔值，只能取 true 或 false。
存储大小：通常占用一个字节。
整数类型：
char： 用于存储字符。
存储大小：通常占用一个字节。
short： 短整数类型。
存储大小：通常占用两个字节。
int： 整数类型。
存储大小：通常占用四个字节。
long： 长整数类型。
存储大小：平台相关，通常为四个字节。
long long： 更长的整数类型。
存储大小：通常占用八个字节。
浮点类型（Floating-point Types）：
float： 单精度浮点数。
存储大小：通常占用四个字节。
double： 双精度浮点数。
存储大小：通常占用八个字节。
long double： 扩展精度浮点数。
存储大小：平台相关。
字符类型（Character Types）：
char： 用于存储字符。
存储大小：通常占用一个字节。
wchar_t： 用于存储宽字符。
存储大小：通常占用两个或四个字节。
空类型（Void Type）：
void： 表示没有类型。

- C++ 中的 sizeof 运算符有什么作用？如何使用它？

	- sizeof 运算符用于获取一个表达式或类型的字节大小，即在内存中占用的空间大小。它是 C++ 中的一个重要运算符，通常用于计算数据类型或变量的大小，以便在进行内存分配或处理二进制数据时进行正确的操作。

- C++ 中的逻辑运算符有哪些？它们的优先级是怎样的？

	- !（逻辑非）
&&（逻辑与）
||（逻辑或）

- 什么是 const 关键字？它在 C++ 中有哪些应用？

- 什么是结构体？C++ 中如何声明和使用结构体？

	- 结构体的成员默认是公共的（public），而类的成员默认是私有的（private）。此外，结构体在没有显式指定访问控制修饰符的情况下，默认为公共的，而类默认为私有。

	- 轻量级的数据封装

- 什么是枚举类型？C++ 中如何声明和使用枚举类型？

	- 是一种用户自定义的数据类型，用于定义具有离散取值的变量。枚举类型使得代码更具可读性，提高了程序的可维护性。

	- 枚举类型常常用于 switch 语句中，以便对离散的取值进行处理。这提高了代码的可读性，避免了使用数字常量的硬编码。

	- C++11 引入了枚举类（Enum class），它具有更严格的作用域和类型安全性。

	- enum class Status {
    Success,
    Failure
};

Status myStatus = Status::Success;

- 指针和引用有什么区别？

	- 使用指针时，需要注意空指针和指针的重新赋值。
引用是变量的别名，它提供了更直观的语法和更安全的操作。
选择使用指针还是引用通常取决于具体的需求和语境。

### 字符串、向量和数组

- 字符串

	- 如何在一个字符串中查找一个子串？

	- 如何删除字符串中的空格？

	- 如何将一个字符串转换为整数？

- 数组

	- 如何实现数组的二分查找算法？

	- 如何对数组进行排序？

- 向量

	- 数组和vector有什么区别？

		- vector是由C++标准库中的一个动态数组实现，原理基于数组的数据结构。包在尾部进行插入和删除，只需要调整尾部指针，不需要移动整个数据块。当元素数量到达当前内存块的容量时，vector会申请一个更大的内存块，进行元素的肤质和转移，并且释放旧的内存块。vector包括指向数组起始位置的指针，数组大小和容量等信息。

	- 数组和vector各项操作时间复杂度是多少？

### 语句

- 如何在C++中使用switch语句，它与if语句有什么区别？

- 请解释一下C++中的goto语句，它的用法和语法。

	- goto 语句是一种控制流语句，允许程序直接跳转到程序中的另一位置。goto 语句的使用在现代编程中通常被认为是不推荐的，因为它可能导致程序结构变得混乱，难以理解和维护。可以在循环/错误中使用

	- 子主题 2

- 请解释一下C++中的continue和break语句，在什么情况下使用它们？

	- 进入下一个循环用continue

	- 结束当前循环用loop

### 函数

- 什么是函数重载？如何实现函数重载？

	- 函数名相同： 必须使用相同的函数名。
参数列表不同： 参数的类型、个数或顺序必须不同。
返回类型可以相同也可以不同： 重载函数的返回类型可以相同，也可以不同。但只有返回类型不同是不够的，必须满足前两个条件。

	- 函数重载是指在同一个作用域内，可以定义多个同名函数，但它们的参数列表必须不同（包括参数的类型、个数或顺序）。编译器根据函数调用时提供的参数信息来确定调用哪个具体的函数。



- 什么是默认参数？如何使用默认参数？

	- 默认参数是在函数声明中指定的一些参数的默认值。当调用函数时没有提供这些参数的值时，将使用默认值。

	- 如何使用

		- 认参数只能在函数声明中指定一次

		- 认参数应该从右向左提供

		- 避免在函数声明和定义中都提供默认值

- 什么是引用参数？为什么要使用引用参数？

- 什么是指针参数？如何使用指针参数？

	- 指针参数是指函数接受一个指针作为参数，通过该指针可以访问或修改函数外部的数据。使用指针参数可以实现在函数中对外部数据的间接操作，对于大型数据结构或需要修改调用者提供的数据的情况非常有用。

- 什么是内联函数？如何使用内联函数？

	- 适用场景： 内联函数适用于短小的函数，通常在头文件中定义。对于复杂的函数，内联可能导致代码膨胀，使得可执行文件变得更大，因此并不是所有函数都适合内联。
避免滥用： 编译器会视情况决定是否内联函数，inline 关键字仅提供了一个建议。滥用内联可能导致编译器忽略建议，从而失去内联的效果。
避免递归： 内联函数通常不应包含递归调用。递归的特性使得在每次递归时都要插入一份新的函数体，可能导致代码膨胀。

	- 内联函数是在编译时将函数体的代码插入到每个函数调用的地方，而不是像普通函数那样通过函数调用的方式进行执行。这样可以减少函数调用的开销，提高程序的执行效率。

- 什么是函数指针？如何使用函数指针？

	- 函数指针是指能够指向函数的指针变量。通过函数指针，可以在运行时动态选择调用哪个函数。函数指针的类型是根据函数的签名来定义的，它指向具有相同参数和返回类型的函数。

- 什么是Lambda表达式？如何使用Lambda表达式？

	- Lambda 表达式使得在需要函数的地方，可以使用一种更紧凑的语法来定义函数，而不必显式地声明一个函数

	- [capture](parameters) -> return_type {
    // 函数体
}
值捕获： [x, y] 按值捕获 x 和 y。
引用捕获： [&x, &y] 按引用捕获 x 和 y。
通用捕获： [=] 按值捕获所有局部变量，[&] 按引用捕获所有局部变量。
    int x = 5, y = 10;

    // 值捕获 x 和 y
    auto valueCapture = [x, y]() {
        std::cout << "Value Capture: " << x << ", " << y << std::endl;
    };

### 类基础

- 什么是构造函数和析构函数？它们的作用是什么？

- 什么是拷贝构造函数？为什么需要它？

- 什么是成员函数和成员变量？

- 什么是虚函数？它的作用是什么？

- 什么是纯虚函数？它的作用是什么？

- 什么是const成员函数？为什么需要它？

- 什么是友元函数和友元类？

- 什么是静态成员变量和静态成员函数？

	- 静态成员函数是属于类而不是属于类的实例的成员函数。它不依赖于类的任何实例，因此可以通过类名直接调用，而不需要创建类的对象。静态成员函数在类的声明中用关键字 static 进行声明和定义。

	- 静态成员函数不能直接访问非静态成员，因为它们没有隐含的 this 指针。
静态成员函数不能使用类的非静态成员，也不能调用非静态成员函数，因为它们不属于任何实例。
静态成员函数通常用于执行一些全局的、与类相关的操作，例如工具函数或工厂函数。

## 其他

### string和char数组有什么区别？什么时候应该使用哪个？

### C++标准库中的算法有哪些？它们可以用于哪些容器？

- C++ 标准库提供了丰富的算法库，包含在 <algorithm> 头文件中。这些算法可以用于各种容器（如数组、vector、list、deque、set、map 等），并提供了通用的接口来执行各种操作。以下是一些常见的算法，它们涵盖了排序、查找、修改、遍历等操作：

### C++标准库中的智能指针有哪些？它们的作用是什么？

### C++标准库中的异常处理机制是什么？它们是如何工作的？

### C++标准库中的文件流有哪些？如何读取和写入文件？

- C++ 标准库中的文件流主要涉及 <fstream> 头文件，提供了用于文件输入和输出的类和函数。主要的文件流类有：

std::ifstream： 用于从文件中读取数据，即输入文件流。
std::ofstream： 用于将数据写入文件，即输出文件流。
std::fstream： 同时具有输入和输出功能的文件流

### C++11 标准库：什么是 C++11 标准库？C++11 标准库中有哪些新增的容器？C++11 标准库中有哪些新增的算法？C++11 标准库中有哪些新增的线程和同步原语？

### 并发编程：什么是并发编程？为什么需要并发编程？如何使用 C++11 中的 std::thread、std::mutex、std::condition_variable 实现并发编程？

## C++面向对象

### 拷贝控制

- 什么是移动构造函数和移动赋值运算符？

- 什么是拷贝构造函数？

	- 用于通过已经存在的对象创建一个新的对象，新对象是原对象的副本，参数通常是对同类型对象的引用。

- 什么是赋值运算符？

	- =

- 什么是默认构造函数（default constructor)？

	- 默认构造函数指的是一个没有任何参数的构造函数，如果没有一个这样的构造函数存在，或者是private的话，会造成编译错误。如果类里面没有提供任何的构造函数，编译器会提供一个implicit default constructor。如果类里面已经定义过了构造函数，我们就要手动定义默认构造函数，这样的默认构造函数称之为explicit default constructor

- 什么时候会调用拷贝构造函数（copy constructor）？

	- 对象初始化： 当一个对象通过另一个对象进行初始化时，拷贝构造函数会被调用。这包括对象的直接初始化和拷贝初始化。

	- 函数参数传递： 当一个对象作为函数的参数传递给另一个函数时，拷贝构造函数会被调用。

	- 函数返回值： 当一个函数返回一个对象时，拷贝构造函数会被调用，将函数内部的局部对象复制到函数外部。
MyClass createObject() {
    // 拷贝构造函数在这里被调用
    return MyClass();
}

	- 对象赋值： 当一个对象被另一个对象赋值时，拷贝构造函数会被调用。MyClass obj2 = obj1;

- 什么时候会调用赋值运算符？

	- 显示赋值操作

	- 初始化对象

	- 返回值赋值

	- 成员函数返回对象

- 如何实现深拷贝和浅拷贝？

	- 深拷贝

		- 深拷贝是指在拷贝对象时，会同时复制对象所引用的动态分配的内存。这样，两个对象拥有独立的内存空间，互不影响。

实现深拷贝通常需要手动编写拷贝构造函数和/或赋值运算符，确保在拷贝对象时分配新的内存并复制数据。

	- 浅拷贝

		- 浅拷贝是指仅复制对象本身，而不复制对象所引用的动态分配的内存。两个对象将共享相同的内存区域，因此修改其中一个对象的数据会影响到另一个对象。

默认情况下，C++提供的拷贝构造函数和赋值运算符执行的是浅拷贝。

			-     // 构造函数
    ShallowCopy(const char *str) {
        data = new char[strlen(str) + 1];
        strcpy(data, str);
    }

    // 拷贝构造函数（默认是浅拷贝）
    ShallowCopy(const ShallowCopy &other) {
        data = other.data;
    }

- 什么是 RAII（Resource Acquisition Is Initialization）技术，如何使用它来管理资源？

- 什么是智能指针？如何防止内存泄漏？

	- 智能指针用于管理动态内存的对象，其主要目的是在避免内存泄漏和方便资源管理

- 如何禁止类的对象进行复制操作？

	- 删除拷贝构造函数和拷贝赋值运算符

### 重载运算与类型转换

- 什么是运算符重载？（operator overloading）

	- 运算符重载是一种编程语言特性，允许程序员重新定义或者扩展已有的运算符的行为。在 C++ 中，运算符重载是通过创建特定的成员函数或全局函数来实现的。通过运算符重载，可以使用户自定义的类或数据类型支持类似内置数据类型的运算和操作。

- 如何重载运算符？

	- 通过成员函数重载

	- 通过全局函数重载

- 重载哪些运算符是合法的？

	- 一元运算符：
+ （正号）
- （负号）
++ （前置和后置递增）
-- （前置和后置递减）
* （解引用）
& （取地址）
! （逻辑非）
~ （按位取反）
二元算术运算符：
+ （加法）
- （减法）
* （乘法）
/ （除法）
% （取模）
二元关系运算符：
== （等于）
!= （不等于）
< （小于）
> （大于）
<= （小于等于）
>= （大于等于）
逻辑运算符：
&& （逻辑与）
|| （逻辑或）
位运算符：
& （按位与）
| （按位或）
^ （按位异或）
<< （左移）
>> （右移）
~ （按位取反）
赋值运算符：
= （赋值）
+= （加等于）
-= （减等于）
*= （乘等于）
/= （除等于）
%= （取模等于）
<<= （左移等于）
>>= （右移等于）
&= （按位与等于）
|= （按位或等于）
^= （按位异或等于）
其他运算符：
() （函数调用）
[] （数组下标）
-> （成员访问）
, （逗号）
->* （成员指针访问）
() （类型转换）

- 什么是隐式类型转换？

- 如何防止意外的隐式类型转换？

- 运算符重载和类型转换有什么限制？

### 面向对象程序设计

- 什么是多重继承？它有什么优点和缺点？

	- 多重继承是一个类可以从多个父类继承属性和行为。

	- 优点：

	- 缺点：可能引入菱形继承，比如一个类同时继承了两个相同基类的类，而最终的派生类又同时继承了这两个类，可能导致二义性（最终的派生类无法确定应该调用哪一个基类进行实现）

- 什么是虚继承？它有什么优点和缺点？

	- 通过在继承路径中使用virtual关键字，可以避免在派生类中生成多个基类的实例，从而解决了菱形继承带来的二义性。

- 什么是右值引用？如何使用右值引用？（C++11新特性）

	- https://www.jianshu.com/p/d19fc8447eaa

- 什么是移动构造函数？为什么需要移动构造函数？

	- 移动构造函数通常用于将资源从一个对象“移动”到另一个对象，而不是进行传统的拷贝操作。这对于处理动态分配的资源，如堆上的内存或其他资源，非常有用，因为移动资源比拷贝资源更高效。

移动构造函数的语法如下：
class MyClass {
public:
    // 移动构造函数
    MyClass(MyClass&& other) noexcept {
        // 进行资源的移动操作，例如，转移指针、拷贝计数等
        // ...
    }

    // 其他成员函数和构造函数
    // ...
};

	- 移动构造函数的参数类型是右值引用 MyClass&&。
移动构造函数通常会在对象的源对象上执行一些操作，例如将指针或资源所有权转移到目标对象，然后将源对象置于一种可析构但不再拥有资源的状态。

	- 避免在资源管理上进行深层次的拷贝，提高程序的性能。例如，在返回局部对象的函数中，使用移动构造函数可以避免拷贝：

- 什么是抽象类？如何定义抽象类？

	- 当我们需要定义某一个成员函数并且希望他被所有的继承类使用，在基类中又没有足够的信息来定义，我们就将这个成员函数定义成一个虚函数，这个基类就变成了一个抽象类。抽象类是一种在面向对象编程中的概念，它不能被实例化，而是被用作其他类的基类。抽象类里面可以包括抽象方法，抽象类只提供这些方法的声明而没有实现。

	- 一个基类通过在类里面定义一个纯虚函数编程抽象类，在基类的成员函数声明前加virtual，函数声明之后加=0。

- 什么是虚函数？为什么需要虚函数？

	- 虚函数让派生类可以重写基类里面成员函数，通过使用虚函数，可以确定调用的是哪个版本的函数，从而实现动态绑定。要在基类里面成员函数之前加virtual声明虚函数，在继承类中重写函数时可以加上override，这样如果函数重写失败编译器会检查并报错。

	- 动态绑定： 使用虚函数可以在运行时（动态时期）确定要调用的函数，而不是在编译时（静态时期）。这被称为动态绑定或运行时多态性。
实现多态性： 虚函数为实现多态性提供了机制，允许不同的派生类对象通过相同的基类接口进行操作。这样，通过基类指针或引用调用虚函数时，实际执行的是具体派生类的版本。

- 什么是纯虚函数？为什么需要纯虚函数？

	- 纯虚函数（Pure Virtual Function）是在C++中定义抽象类（Abstract Class）的一种机制。抽象类是不能被实例化的类，而包含至少一个纯虚函数的类就是抽象类。派生类必须实现抽象类里面的纯虚函数，不然他自己也会变成一个抽象类。

### 模板与泛型编程

- 什么是C++模板？你能给一个例子吗？

- 什么是函数模板？如何使用函数模板？

- 什么是模板类？它有什么作用？

- 什么是模板偏特化（Template Partial Specialization）？它有什么作用？

- 什么是类型推导（Type Deduction）？C++11引入了哪些类型推导方法？

## C++标准库

### IO库

- 如何在 C++ 中读取文件？如何将读取的内容写入到文件中？

- 解释 C++ 中的缓冲区是什么，以及为什么要使用缓冲区？

	- 在 C++ 中，标准库提供了一些缓冲区相关的类和函数，例如：

std::streambuf： 是 C++ 标准库用于缓冲区管理的基类，提供了基本的缓冲区操作。
std::cin、std::cout、std::cerr、std::clog： 这些标准输入输出流都使用了缓冲区，以提高输入输出性能。
std::endl： 是一个输出流操作符，它不仅会插入换行符，还会刷新缓冲区，确保之前的输出立即被写入。

- 如何将 C++ 标准输出重定向到文件中？

### 顺序容器

- vector 和 array 有什么区别？

	- vector

		- vector在堆中实现了一段连续的内存空间来存放元素

	- array

		- array在声明时要固定大小，并且之后大小固定不变，在内存上占一段连续的存储空间

		- array在c++中是object，当我们把array作为一个value使用的时候，编译器会把它衰变成一个指向array第一个元素的指针。

		- 当被作为参数传递时，不能确保传入的array大小保持一致，因为都是指向第一个元素的指针，因此需要传入大小的信息，但我们仍然可以对他进行索引

- 如何在 vector 和 deque 中快速插入和删除元素？

	- deque除了有vector有的push_back() 和pop_back()之外，还有push_front()和pop_front()，使用迭代器和deque.insert(it, element)可以在任意位置插入元素

- list 和 vector 的区别是什么？它们适用于不同的场景吗？

	- list底层实现是双向链表，vector是数组

	- vector在中间节点进行插入删除会导致内存拷贝，list不会

	- vector一次性分配好内存，不够时才进行翻倍扩容，list每次插入新的节点就会进行内存申请

	- vector随机访问性能好，插入删除性能差，list随机访问性能差，插入性能好

- 如何在 vector 中实现自动扩容？

	- std::vector 是一个动态数组，它可以自动扩容以适应存储元素的需求。std::vector 内部使用了动态内存分配来管理元素的存储，并提供了自动扩容的机制。当向 std::vector 中添加元素时，如果元素数量超过当前容量，std::vector 会自动分配更多的内存，并将已有元素复制到新的内存空间中。

- 如何在 vector 中实现元素去重？

	- 最简单的方法是先对 std::vector 进行排序，然后使用 std::unique 函数去除相邻的重复元素，最后使用 erase 函数删除重复元素后面的元素。

	-     // 先对 vector 进行排序
    std::sort(myVector.begin(), myVector.end());

    // 使用 std::unique 去除相邻的重复元素
    auto uniqueEnd = std::unique(myVector.begin(), myVector.end());

    // 使用 erase 删除重复元素后面的元素
    myVector.erase(uniqueEnd, myVector.end());

- vector 和 list 中的迭代器有什么区别？

	- 由于vector维护的是一个线性空间，普通指针具备作为vector迭代器的所有条件，就不需要重载operator+, operator*之类的，vector的迭代器是原生指针，是随机访问迭代器（Random Access Iterator），允许在常数时间内进行以下操作：
1. 按索引访问元素：iterator[i]。
2. 移动迭代器：iterator + n 或 iterator - n

	- list 是一个双向链表，其迭代器是双向迭代器（Bidirectional Iterator）。双向迭代器允许在常数时间内进行以下操作：

- 如何使用 vector 实现栈和队列？

	- push_back(), pop_back(), push_front(), pop_front()

- 顺序容器的类型有哪些？

	- vector

	- string

	- list

	- array

	- deque

	- forwarded_list

	- 栈是以底层容器完成其所有的工作，对外提供统一的接口，底层容器是可插拔的（也就是说我们可以控制使用哪种容器来实现栈的功能）。

所以STL中栈往往不被归类为容器，而被归类为container adapter（容器适配器）。我们常用的SGI STL，如果没有指定底层实现的话，默认是以deque为缺省情况下栈的底层结构。

deque是一个双向队列，只要封住一段，只开通另一端就可以实现栈的逻辑了。

SGI STL中 队列底层实现缺省情况下一样使用deque实现的。

也可以指定list 为起底层实现，初始化queue的语句如下：
std::queue<int, std::list<int>> third; // 定义以list为底层容器的队列

### 泛型算法（generic algorithm)

- 给定一个容器，如何使用泛型算法对容器进行排序？

	- sort()

- 什么情况下会发生迭代器失效？

	- 插入或者删除元素

	- 清空内存

	- 容器重新分配内存

- 给定一个容器，如何使用泛型算法查找容器中的最大/最小值？

	- 可以使用泛型算法 std::max_element 和 std::min_element 分别查找容器中的最大值和最小值。这两个算法返回一个指向最大（最小）元素的迭代器。

### 关联容器

- 什么是C++关联容器？有哪些常见的关联容器？

	- C++ 中的关联容器（Associative Containers）是一种特殊类型的容器，它们根据元素的键（key）进行组织和存储。关联容器提供了高效的元素查找、插入和删除操作，其底层实现通常基于树结构（如红黑树）或哈希表。

C++ 标准库提供了几种关联容器，其中最常见的有 std::map、std::set、std::multimap、std::multiset、std::unordered_map、std::unordered_set、std::unordered_multimap、std::unordered_multiset

- unordered_map和map有什么区别？

	- map底层是基于红黑树实现的，元素的排列顺序是有序的，unordered_map是基于哈希表实现的，元素的排列顺序是杂乱无章的。

- 什么情况下应该使用map，什么情况下应该使用unordered_map？

- C++关联容器中的元素是如何排序的？

- 关联容器中的迭代器和指针有什么区别？

- 如何在C++关联容器中使用自定义比较函数进行排序？

### 动态内存

- 什么是智能指针？它们是如何工作的？
什么是数组和指针之间的区别？如何动态分配数组？
什么是虚拟析构函数？为什么需要它？
如何在 C++ 中处理异常情况，如内存分配失败？

	- 什么是智能指针？它们是如何工作的？

		- 智能指针是为了解决动态分配内存导致内存泄漏和多次释放统一内存所提出的，c11标准中放在<memory>头文件。

		- 分类

			- std::unique_ptr

				- 独占智能指针提供对动态分配的单一对象所有权进行独占管理，通过独占管理，确保只有一个unique_ptr可以拥有指定的内存资源。移动语意和右值引用允许unique_ptr在所有权转移时高效的进行转移

			- std::shared_ptr

				- 共享智能指针允许多个智能指针共享一块资源，内部使用计数器来跟踪对象被共享的次数，当计数器为0时，资源被释放。提供灵活的资源共享，但也可能存在循环引用的问题。

			- std::weak_ptr

				- 通过将std::weak_ptr使用在循环引用的其中一个指针上，可以打破循环引用。

	- 什么是数组和指针之间的区别？如何动态分配数组？

		- 数组是一个静态大小的、连续存储的数据结构，而指针可以用于动态分配内存并创建可变大小的数据结构。

	- 什么是虚拟析构函数？为什么需要它？

		- 虚拟析构函数是一个带有virtual关键字的函数，主要作用是确保在通过基类指针删除派生类对象的时候，能够正确调用派生类的析构函数，从而释放对象所占用的资源。

	- 如何在 C++ 中处理异常情况，如内存分配失败？

		- try catch throw

- 什么是动态内存分配？如何在 C++ 中进行动态内存分配？

	- 动态内存分配是指在程序运行时（运行阶段）根据需要动态地分配内存空间。与静态内存分配（编译阶段确定大小）不同，动态内存分配允许在运行时根据实际需求灵活地分配和释放内存。

在 C++ 中，动态内存分配通常通过 new 和 delete 运算符来进行。

- C++ 中的 new 和 malloc 有什么区别？

	- 类型安全性

	- 返回类型

	- 内存分配失败时的行为

	- 内存块大小

	- 释放内存的方式

- 什么是内存泄漏？如何避免内存泄漏？

	- 由于疏忽或者错误造成了程序未能释放掉不再使用的内存的情况。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制，因而造成了对内存的浪费

	- 分类

		- heap leak堆内存泄漏

			- 通过malloc和reloc new等从堆中分配的一块内存，再是完成后必须通过调用对应的free或者delete删掉，如果程序设计导致这部分没有释放，则这块内存将导致系统效能降低。

		- resource leak系统资源泄漏

			- 主要指程序使用系统分配的资源比如bitmap, handle, socket等没有使用相应的函数释放掉，导致系统资源的浪费

		- 没有将基类的析构函数定义为虚函数

			- 没有将基类的析构函数定义为虚函数，如果基类的析构函数不是virtual，那么子类的析构函数不会被调用，子类资源没有被正确释放，因此造成内存泄漏

	- 如何防止内存泄漏

		- 将内存的分配封装在类中，构造函数分配内存，析构函数释放内存；使用智能指针；

- 什么是动态多态性？如何在 C++ 中实现动态多态性？

	- "动态多态性" 是面向对象编程中的一个概念，也称为 "运行时多态性"（Runtime Polymorphism）。它是通过使用虚函数（virtual functions）和运行时绑定（dynamic binding）来实现的。

动态多态性允许在运行时确定对象的实际类型，并调用相应的函数，而不是在编译时确定。这使得程序能够以一种更灵活、可扩展的方式处理不同类型的对象。

	- 使用virtual和override

- 如何在 C++ 中删除动态分配的内存？

	- 动态分配的内存可以使用 new 和 delete 或 malloc 和 free 进行分配和释放。使用 new 和 delete 更为常见

