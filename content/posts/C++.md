---
weight: 4
title: "C++知识点整理总结"
date: 2023-03-20T21:57:40+08:00
lastmod: 2023-03-20T16:45:40+08:00
draft: false
author: "Jiawen Liu"
authorLink: "https://jiawenliu0901.github.io"
description: "C++知识点整理总结"
tags: ["C++"]
categories: ["C++八股"]
lightgallery: true
---
# C++ 常见问题(补充)

## C++基础

### 变量和基本类型

- C++ 中的基本数据类型有哪些？它们的存储大小是多少？
| 数据类型       | 描述                           | 存储大小（字节）        |
|----------------|------------------------------|------------------------|
| `bool`         | 布尔型，表示真或假             | 1                      |
| `char`         | 字符型，通常表示一个字符       | 1                      |
| `signed char`  | 有符号字符型                  | 1                      |
| `unsigned char`| 无符号字符型                  | 1                      |
| `wchar_t`      | 宽字符型，表示宽字符           | 2 或 4                 |
| `char16_t`     | 16 位字符型，表示 UTF-16 字符  | 2                      |
| `char32_t`     | 32 位字符型，表示 UTF-32 字符  | 4                      |
| `short`        | 短整型                        | 2                      |
| `unsigned short`| 无符号短整型                 | 2                      |
| `int`          | 整型                          | 4                      |
| `unsigned int` | 无符号整型                    | 4                      |
| `long`         | 长整型                        | 4 或 8                 |
| `unsigned long`| 无符号长整型                  | 4 或 8                 |
| `long long`    | 长长整型                      | 8                      |
| `unsigned long long`| 无符号长长整型           | 8                      |
| `float`        | 单精度浮点型                  | 4                      |
| `double`       | 双精度浮点型                  | 8                      |
| `long double`  | 扩展精度浮点型                | 8、12 或 16            |


- C++ 中的 sizeof 运算符有什么作用？如何使用它？

	- sizeof 运算符用于获取一个表达式或类型的字节大小，即在内存中占用的空间大小。它是 C++ 中的一个重要运算符，通常用于计算数据类型或变量的大小，以便在进行内存分配或处理二进制数据时进行正确的操作。

- C++ 中的逻辑运算符有哪些？它们的优先级是怎样的？

	- !（逻辑非）&&（逻辑与）||（逻辑或）

- 什么是 const 关键字？它在 C++ 中有哪些应用？
| 应用场景                   | 说明                                                                 |
|---------------------------|--------------------------------------------------------------------|
| `const` 变量               | 定义不可修改的常量变量。                                               |
| 指向常量的指针             | 指针指向的值是常量，不允许通过该指针修改值。                               |
| 常量指针                   | 指针本身是常量，不允许修改指针本身的值。                                 |
| 指向常量的常量指针         | 指针本身和指针指向的值都是常量。                                       |
| `const` 成员函数            | 定义不会修改对象状态的成员函数。                                       |
| `const` 对象               | 定义常量对象，常量对象不能调用非常量成员函数。                             |
| `const` 参数               | 防止在函数内部修改参数的值。                                           |
| `const` 返回类型            | 防止修改函数返回的值。                                                 |


- 什么是结构体？C++ 中如何声明和使用结构体？

	- 结构体的成员默认是公共的（public），而类的成员默认是私有的（private）。此外，结构体在没有显式指定访问控制修饰符的情况下，默认为公共的，而类默认为私有。是轻量级的数据封装。

- 什么是枚举类型？C++ 中如何声明和使用枚举类型？

	- 是一种用户自定义的数据类型，用于定义具有离散取值的变量。枚举类型使得代码更具可读性，提高了程序的可维护性。

	- 枚举类型常常用于 switch 语句中，以便对离散的取值进行处理。这提高了代码的可读性，避免了使用数字常量的硬编码。

	- C++11 引入了枚举类（Enum class），它具有更严格的作用域和类型安全性。

	- enum class Status {Success,Failure};
          Status myStatus = Status::Success;

- 指针和引用有什么区别？

	- 使用指针时，需要注意空指针和指针的重新赋值。
引用是变量的别名，它提供了更直观的语法和更安全的操作。
选择使用指针还是引用通常取决于具体的需求和语境。

### 字符串、向量和数组

- 字符串

	- 如何在一个字符串中查找一个子串？

	- 如何删除字符串中的空格？

	- 如何将一个字符串转换为整数？

- 数组

	- 如何实现数组的二分查找算法？

	- 如何对数组进行排序？

- 向量

	- 数组和vector有什么区别？

		- vector是由C++标准库中的一个动态数组实现，原理基于数组的数据结构。包在尾部进行插入和删除，只需要调整尾部指针，不需要移动整个数据块。当元素数量到达当前内存块的容量时，vector会申请一个更大的内存块，进行元素的肤质和转移，并且释放旧的内存块。vector包括指向数组起始位置的指针，数组大小和容量等信息。

	- 数组和vector各项操作时间复杂度是多少？

### 语句

- 如何在C++中使用switch语句，它与if语句有什么区别？

- 请解释一下C++中的goto语句，它的用法和语法。

	- goto 语句是一种控制流语句，允许程序直接跳转到程序中的另一位置。goto 语句的使用在现代编程中通常被认为是不推荐的，因为它可能导致程序结构变得混乱，难以理解和维护。可以在循环/错误中使用

	- 子主题 2

- 请解释一下C++中的continue和break语句，在什么情况下使用它们？

	- 进入下一个循环用continue

	- 结束当前循环用loop

### 函数

- 什么是函数重载？如何实现函数重载？

	- 函数名相同： 必须使用相同的函数名。
参数列表不同： 参数的类型、个数或顺序必须不同。
返回类型可以相同也可以不同： 重载函数的返回类型可以相同，也可以不同。但只有返回类型不同是不够的，必须满足前两个条件。

	- 函数重载是指在同一个作用域内，可以定义多个同名函数，但它们的参数列表必须不同（包括参数的类型、个数或顺序）。编译器根据函数调用时提供的参数信息来确定调用哪个具体的函数。



- 什么是默认参数？如何使用默认参数？

	- 默认参数是在函数声明中指定的一些参数的默认值。当调用函数时没有提供这些参数的值时，将使用默认值。

	- 如何使用

		- 认参数只能在函数声明中指定一次

		- 认参数应该从右向左提供

		- 避免在函数声明和定义中都提供默认值

- 什么是引用参数？为什么要使用引用参数？

- 什么是指针参数？如何使用指针参数？

	- 指针参数是指函数接受一个指针作为参数，通过该指针可以访问或修改函数外部的数据。使用指针参数可以实现在函数中对外部数据的间接操作，对于大型数据结构或需要修改调用者提供的数据的情况非常有用。

- 什么是内联函数？如何使用内联函数？

	- 适用场景： 内联函数适用于短小的函数，通常在头文件中定义。对于复杂的函数，内联可能导致代码膨胀，使得可执行文件变得更大，因此并不是所有函数都适合内联。
避免滥用： 编译器会视情况决定是否内联函数，inline 关键字仅提供了一个建议。滥用内联可能导致编译器忽略建议，从而失去内联的效果。
避免递归： 内联函数通常不应包含递归调用。递归的特性使得在每次递归时都要插入一份新的函数体，可能导致代码膨胀。

	- 内联函数是在编译时将函数体的代码插入到每个函数调用的地方，而不是像普通函数那样通过函数调用的方式进行执行。这样可以减少函数调用的开销，提高程序的执行效率。

- 什么是函数指针？如何使用函数指针？

	- 函数指针是指能够指向函数的指针变量。通过函数指针，可以在运行时动态选择调用哪个函数。函数指针的类型是根据函数的签名来定义的，它指向具有相同参数和返回类型的函数。

- 什么是Lambda表达式？如何使用Lambda表达式？

	- Lambda 表达式使得在需要函数的地方，可以使用一种更紧凑的语法来定义函数，而不必显式地声明一个函数

	- [capture](parameters) -> return_type {
    // 函数体
}
值捕获： [x, y] 按值捕获 x 和 y。
引用捕获： [&x, &y] 按引用捕获 x 和 y。
通用捕获： [=] 按值捕获所有局部变量，[&] 按引用捕获所有局部变量。
    int x = 5, y = 10;

    // 值捕获 x 和 y
    auto valueCapture = [x, y]() {
        std::cout << "Value Capture: " << x << ", " << y << std::endl;
    };

### 类基础

- 什么是构造函数和析构函数？它们的作用是什么？

- 什么是拷贝构造函数？为什么需要它？

- 什么是成员函数和成员变量？

- 什么是虚函数？它的作用是什么？

- 什么是纯虚函数？它的作用是什么？

- 什么是const成员函数？为什么需要它？

- 什么是友元函数和友元类？

- 什么是静态成员变量和静态成员函数？

	- 静态成员函数是属于类而不是属于类的实例的成员函数。它不依赖于类的任何实例，因此可以通过类名直接调用，而不需要创建类的对象。静态成员函数在类的声明中用关键字 static 进行声明和定义。

	- 静态成员函数不能直接访问非静态成员，因为它们没有隐含的 this 指针。
静态成员函数不能使用类的非静态成员，也不能调用非静态成员函数，因为它们不属于任何实例。
静态成员函数通常用于执行一些全局的、与类相关的操作，例如工具函数或工厂函数。

## 其他

### string和char数组有什么区别？什么时候应该使用哪个？

### C++标准库中的算法有哪些？它们可以用于哪些容器？

- C++ 标准库提供了丰富的算法库，包含在 <algorithm> 头文件中。这些算法可以用于各种容器（如数组、vector、list、deque、set、map 等），并提供了通用的接口来执行各种操作。以下是一些常见的算法，它们涵盖了排序、查找、修改、遍历等操作：

### C++标准库中的智能指针有哪些？它们的作用是什么？

### C++标准库中的异常处理机制是什么？它们是如何工作的？

### C++标准库中的文件流有哪些？如何读取和写入文件？

- C++ 标准库中的文件流主要涉及 <fstream> 头文件，提供了用于文件输入和输出的类和函数。主要的文件流类有：

std::ifstream： 用于从文件中读取数据，即输入文件流。
std::ofstream： 用于将数据写入文件，即输出文件流。
std::fstream： 同时具有输入和输出功能的文件流

### C++11 标准库：什么是 C++11 标准库？C++11 标准库中有哪些新增的容器？C++11 标准库中有哪些新增的算法？C++11 标准库中有哪些新增的线程和同步原语？

### 并发编程：什么是并发编程？为什么需要并发编程？如何使用 C++11 中的 std::thread、std::mutex、std::condition_variable 实现并发编程？

## C++标准库

### IO库

- 如何在 C++ 中读取文件？如何将读取的内容写入到文件中？

- 解释 C++ 中的缓冲区是什么，以及为什么要使用缓冲区？

	- 在 C++ 中，标准库提供了一些缓冲区相关的类和函数，例如：

std::streambuf： 是 C++ 标准库用于缓冲区管理的基类，提供了基本的缓冲区操作。
std::cin、std::cout、std::cerr、std::clog： 这些标准输入输出流都使用了缓冲区，以提高输入输出性能。
std::endl： 是一个输出流操作符，它不仅会插入换行符，还会刷新缓冲区，确保之前的输出立即被写入。

- 如何将 C++ 标准输出重定向到文件中？

### 顺序容器

- vector 和 array 有什么区别？

	- vector

		- vector在堆中实现了一段连续的内存空间来存放元素

	- array

		- array在声明时要固定大小，并且之后大小固定不变，在内存上占一段连续的存储空间

		- array在c++中是object，当我们把array作为一个value使用的时候，编译器会把它衰变成一个指向array第一个元素的指针。

		- 当被作为参数传递时，不能确保传入的array大小保持一致，因为都是指向第一个元素的指针，因此需要传入大小的信息，但我们仍然可以对他进行索引

- 如何在 vector 和 deque 中快速插入和删除元素？

	- deque除了有vector有的push_back() 和pop_back()之外，还有push_front()和pop_front()，使用迭代器和deque.insert(it, element)可以在任意位置插入元素

- list 和 vector 的区别是什么？它们适用于不同的场景吗？

	- list底层实现是双向链表，vector是数组

	- vector在中间节点进行插入删除会导致内存拷贝，list不会

	- vector一次性分配好内存，不够时才进行翻倍扩容，list每次插入新的节点就会进行内存申请

	- vector随机访问性能好，插入删除性能差，list随机访问性能差，插入性能好

- 如何在 vector 中实现自动扩容？

	- std::vector 是一个动态数组，它可以自动扩容以适应存储元素的需求。std::vector 内部使用了动态内存分配来管理元素的存储，并提供了自动扩容的机制。当向 std::vector 中添加元素时，如果元素数量超过当前容量，std::vector 会自动分配更多的内存，并将已有元素复制到新的内存空间中。

- 如何在 vector 中实现元素去重？

	- 最简单的方法是先对 std::vector 进行排序，然后使用 std::unique 函数去除相邻的重复元素，最后使用 erase 函数删除重复元素后面的元素。

	-     // 先对 vector 进行排序
    std::sort(myVector.begin(), myVector.end());

    // 使用 std::unique 去除相邻的重复元素
    auto uniqueEnd = std::unique(myVector.begin(), myVector.end());

    // 使用 erase 删除重复元素后面的元素
    myVector.erase(uniqueEnd, myVector.end());

- vector 和 list 中的迭代器有什么区别？

	- 由于vector维护的是一个线性空间，普通指针具备作为vector迭代器的所有条件，就不需要重载operator+, operator*之类的，vector的迭代器是原生指针，是随机访问迭代器（Random Access Iterator），允许在常数时间内进行以下操作：
1. 按索引访问元素：iterator[i]。
2. 移动迭代器：iterator + n 或 iterator - n

	- list 是一个双向链表，其迭代器是双向迭代器（Bidirectional Iterator）。双向迭代器允许在常数时间内进行以下操作：

- 如何使用 vector 实现栈和队列？

	- push_back(), pop_back(), push_front(), pop_front()

- 顺序容器的类型有哪些？

	- vector

	- string

	- list

	- array

	- deque

	- forwarded_list

	- 栈是以底层容器完成其所有的工作，对外提供统一的接口，底层容器是可插拔的（也就是说我们可以控制使用哪种容器来实现栈的功能）。

所以STL中栈往往不被归类为容器，而被归类为container adapter（容器适配器）。我们常用的SGI STL，如果没有指定底层实现的话，默认是以deque为缺省情况下栈的底层结构。

deque是一个双向队列，只要封住一段，只开通另一端就可以实现栈的逻辑了。

SGI STL中 队列底层实现缺省情况下一样使用deque实现的。

也可以指定list 为起底层实现，初始化queue的语句如下：
std::queue<int, std::list<int>> third; // 定义以list为底层容器的队列

### 泛型算法（generic algorithm)

- 给定一个容器，如何使用泛型算法对容器进行排序？

	- sort()

- 什么情况下会发生迭代器失效？

	- 插入或者删除元素

	- 清空内存

	- 容器重新分配内存

- 给定一个容器，如何使用泛型算法查找容器中的最大/最小值？

	- 可以使用泛型算法 std::max_element 和 std::min_element 分别查找容器中的最大值和最小值。这两个算法返回一个指向最大（最小）元素的迭代器。

### 关联容器

- 什么是C++关联容器？有哪些常见的关联容器？

	- C++ 中的关联容器（Associative Containers）是一种特殊类型的容器，它们根据元素的键（key）进行组织和存储。关联容器提供了高效的元素查找、插入和删除操作，其底层实现通常基于树结构（如红黑树）或哈希表。

C++ 标准库提供了几种关联容器，其中最常见的有 std::map、std::set、std::multimap、std::multiset、std::unordered_map、std::unordered_set、std::unordered_multimap、std::unordered_multiset

- unordered_map和map有什么区别？

	- map底层是基于红黑树实现的，元素的排列顺序是有序的，unordered_map是基于哈希表实现的，元素的排列顺序是杂乱无章的。

- 什么情况下应该使用map，什么情况下应该使用unordered_map？

- C++关联容器中的元素是如何排序的？

- 关联容器中的迭代器和指针有什么区别？

- 如何在C++关联容器中使用自定义比较函数进行排序？

### 动态内存

- 什么是智能指针？它们是如何工作的？
什么是数组和指针之间的区别？如何动态分配数组？
什么是虚拟析构函数？为什么需要它？
如何在 C++ 中处理异常情况，如内存分配失败？

	- 什么是智能指针？它们是如何工作的？

		- 智能指针是为了解决动态分配内存导致内存泄漏和多次释放统一内存所提出的，c11标准中放在<memory>头文件。

		- 分类

			- std::unique_ptr

				- 独占智能指针提供对动态分配的单一对象所有权进行独占管理，通过独占管理，确保只有一个unique_ptr可以拥有指定的内存资源。移动语意和右值引用允许unique_ptr在所有权转移时高效的进行转移

			- std::shared_ptr

				- 共享智能指针允许多个智能指针共享一块资源，内部使用计数器来跟踪对象被共享的次数，当计数器为0时，资源被释放。提供灵活的资源共享，但也可能存在循环引用的问题。

			- std::weak_ptr

				- 通过将std::weak_ptr使用在循环引用的其中一个指针上，可以打破循环引用。

	- 什么是数组和指针之间的区别？如何动态分配数组？

		- 数组是一个静态大小的、连续存储的数据结构，而指针可以用于动态分配内存并创建可变大小的数据结构。

	- 什么是虚拟析构函数？为什么需要它？

		- 虚拟析构函数是一个带有virtual关键字的函数，主要作用是确保在通过基类指针删除派生类对象的时候，能够正确调用派生类的析构函数，从而释放对象所占用的资源。

	- 如何在 C++ 中处理异常情况，如内存分配失败？

		- try catch throw

- 什么是动态内存分配？如何在 C++ 中进行动态内存分配？

	- 动态内存分配是指在程序运行时（运行阶段）根据需要动态地分配内存空间。与静态内存分配（编译阶段确定大小）不同，动态内存分配允许在运行时根据实际需求灵活地分配和释放内存。

在 C++ 中，动态内存分配通常通过 new 和 delete 运算符来进行。

- C++ 中的 new 和 malloc 有什么区别？

	- 类型安全性

	- 返回类型

	- 内存分配失败时的行为

	- 内存块大小

	- 释放内存的方式

- 什么是内存泄漏？如何避免内存泄漏？

	- 由于疏忽或者错误造成了程序未能释放掉不再使用的内存的情况。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制，因而造成了对内存的浪费

	- 分类

		- heap leak堆内存泄漏

			- 通过malloc和reloc new等从堆中分配的一块内存，再是完成后必须通过调用对应的free或者delete删掉，如果程序设计导致这部分没有释放，则这块内存将导致系统效能降低。

		- resource leak系统资源泄漏

			- 主要指程序使用系统分配的资源比如bitmap, handle, socket等没有使用相应的函数释放掉，导致系统资源的浪费

		- 没有将基类的析构函数定义为虚函数

			- 没有将基类的析构函数定义为虚函数，如果基类的析构函数不是virtual，那么子类的析构函数不会被调用，子类资源没有被正确释放，因此造成内存泄漏

	- 如何防止内存泄漏

		- 将内存的分配封装在类中，构造函数分配内存，析构函数释放内存；使用智能指针；

- 什么是动态多态性？如何在 C++ 中实现动态多态性？

	- "动态多态性" 是面向对象编程中的一个概念，也称为 "运行时多态性"（Runtime Polymorphism）。它是通过使用虚函数（virtual functions）和运行时绑定（dynamic binding）来实现的。动态多态性允许在运行时确定对象的实际类型，并调用相应的函数，而不是在编译时确定。这使得程序能够以一种更灵活、可扩展的方式处理不同类型的对象。
	- 使用virtual和override

- 如何在 C++ 中删除动态分配的内存？

	- 动态分配的内存可以使用 new 和 delete 或 malloc 和 free 进行分配和释放。使用 new 和 delete 更为常见

