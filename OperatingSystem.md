---
weight: 4
title: "操作系统知识点整理总结"
date: 2023-03-20T21:57:40+08:00
lastmod: 2023-03-20T16:45:40+08:00
draft: false
author: "Jiawen Liu"
authorLink: "https://dillonzq.com"
description: "操作系统知识点整理总结"
tags: ["Operating System"]
categories: ["Operating System"]
lightgallery: true

---
# 操作系统常见面试题

## 参考资料

### https://www.icourse163.org/course/HIT-1002531008

### https://www.bilibili.com/video/BV1CP4y1k7i8/?spm_id_from=333.337.search-card.all.click

## 常见问题

### 操作系统基础

- 操作系统有哪些基础组成部分

	- 进程管理

	- 存储管理

	- 文件管理

	- 设备管理

	- 系统调用

### 进程与线程

- 进程

	- 进程通信有哪些方式？

		- 共享存储

			- 基于数据结构的共享

			- 基于存储区的共享

		- 消息传递

			- 直接通信方式

				- 指明进程的PID来接收

			- 间接通信方式

				- 通过信箱作为通信

		- 管道通信

	- 什么是死锁？死锁的条件是什么？如何避免死锁？

		- 如果一个进程中的每一个进程都在等待只能由该进程中的其他进程才能引发的事件，该进程集合就是死锁

		- 条件

			- 互斥：只有对必须互斥使用的资源争抢才会导致死锁

			- 占有和等待：已经得到了某个资源的进程可以再请求新的资源

			- 不可抢占：已经分配给一个进程的资源不能强制性的被强占，只能被占有他的进程释放

			- 循环等待：死锁发生时，系统中一定有两个或者两个以上的进程组成的一条环路，该环路中的每个进程都在等待着下一个进程所占有的资源

		- 如何避免死锁

			- 死锁的检测与解除

				- 死锁的检测

					- 在资源分配图中，找出既不阻塞也不是孤点的进程Pi，消去他所有的请求边和分配边，使之成为孤立的节点。若能消去所有的变，这个图就是可完全简化的，系统不会发生死锁

				- 死锁的解除

					- 资源剥夺法

						- 挂起（暂时放到外存上）某些进程，并剥夺他的资源，分配给其他的死锁进程。

					- 撤销进程法

						- 强制撤销部分死锁进程，代价可能会很大，因为有的进程可能已经运行了很长时间

					- 进程回退法

						- 让一个进程会滚到不足以发生死锁的地步，要求进程要记录进程的历史信息并设置还原点

			- 死锁预防

				- 破坏互斥条件

					- 例如spooling技术允许若干个进程同时输出，但是唯一请求物理打印机的进程是打印机守护进程

				- 破坏占有个等待条件

					- 1. 规定所有程序开始执行之前请求所需要的全部资源2. 要求当一个进程请求资源是，先暂时释放其当前占用的所有资源，然后在尝试一次获得所需要的全部资源

				- 破坏不可抢占条件

					- 保证每个进程在任何时刻只能占有一个资源，如果要请求另一个资源必须先释放

				- 破坏环路等待

					- 顺序资源分配法：每个进程按照编号递增的方式对资源进行请求，同类资源一次性申请完

			- 死锁避免

				- 安全状态

					- 如果没有死锁发生，并且即使所有进程突然对资源的最大需求，也仍然存在某种调度次序是的所有的进程可以安全执行完毕，称之为安全状态。如果系统进入不安全状态，可能会发生死锁。

				- 银行家算法

					- 判断对请求的满足是否会进入不安全状态

						- 单个资源的银行家算法

						- 多个资源的银行家算法

				- 安全序列

					- 如果按照这种顺序分配资源，则每个进程都能顺利完成，要能找到一个安全序列系统就是安全状态。安全序列可以有多个。

	- 进程的状态转换图是什么？


	- 进程间的资源竞争有哪些种类？

		- 死锁

			- 各进程互相等待对方手里的资源，导致各个进程都阻塞，无法向前推进

		- 饥饿

			- 因为某些进程一直无法获得所需要的资源，一个或多个进程被无限期的延迟。发生饥饿的进程既可能是阻塞态，也可能是就绪态

	- 操作系统是如何保证多个进程并发执行的？

		- 处理机调度是对处理机进行分配，即从就绪队列中按照一定的算法选择一个进程并将处理机分配给他运行，从而实现并发执行

	- 操作系统如何处理进程异常和中断？

		- 当CPU在执行用户第i条指令时检测到一个异常事件，或者在执行第i条指令后发现一个中断请求信号，则CPU打断当前的用户程序转到相应的中断/异常处理程序去执行。

	- 如何实现操作系统的进程间通信机制？

	- 操作系统中的进程同步机制有哪些？如何解决进程同步的问题？

		- 信号量机制

		- 互斥锁

		- 条件变量

		- 读写锁

	- 操作系统中的信号量机制是什么？如何使用信号量实现进程同步和互斥？
	信号量是一个计数器，可以用来控制多个进程对共享资源的访问。意图在于进程间同步。这种通信方式主要用于解决与同步相关的问题并避免竞争条件

		- 整型信号量

			- 用原语实现P、V操作，避免并发、异步产生的问题，用一个整数记录资源的数量，但是不满足让权等待，可能会产生忙等。

		-  

		- 记录型信号量

			- P操作时，进程进入阻塞台，并将相关信息挂到等待队列中，自动放弃处理机，遵循让权等待原则

		- 如何使用信号量实现进程的同步和互斥？
		互斥（Mutual Exclusion）是指在同一时刻只允许一个进程访问某个资源。可以通过初始化一个值为1的信号量来实现互斥。在这种情况下，信号量充当了互斥锁（Mutex）的角色。在进入临界区之前，进程调用wait(S)。如果S的值大于0（表示没有其他进程在临界区中），进程进入临界区并执行，同时S被减到0，阻止其他进程进入。当进程离开临界区时，调用signal(S)将S加回1，表示临界区可用。
		进程同步是指在某些点上协调进程的执行顺序，以确保某些事件的发生顺序。例如，一个进程必须等待另一个进程完成某项工作之后才能继续执行。可以通过初始化一个值为0的信号量来实现同步。

	- 什么是线程池？如何实现线程池的管理和调度？

	- 操作系统中如何实现文件的共享和保护？

	- 什么是进程？

		- 进程是具有独立功能的程序在一个数据集合上运行的过程，是系统进行资源分配和调用的一个独立单位，即时间片分配的独立单位，决定了进程是一个动态的、过程性的概念

	- 进程和线程的区别是什么？

		- 调度

			- 传统的OS中，进程拥有独立调度。进程调度每次都要进行上下文切换，开销很大，线程切换代价很低。拥有线程的系统线程是独立调度的基本单位。

		- 并发性

			- 进程和线程都可以并发执行。引入线程后同一个进程中的多个线程也可以并发执行，从而提高吞吐量和系统资源利用率。

		- 拥有资源

			- 进程是系统中拥有资源的基本单位，而线程除了一些必要的能保证独立运行的资源意外只可以访问隶属于进程的系统资源，主要表现在属于同一进程的线程都有相同的地址空间，从而在线程切换之间节省了时空开销。

		- 独立性

			- 每个进程之间都有独立的地址空间和资源

		- 系统开销

			- 创建或者撤销进程时，系统要分配/回收PCB和其他资源。进程切换涉及上下文的切换，线程切换只保存和设置少量寄存器内容，开销较小。线程之间的同步与通信非常容易实现，甚至不用OS干涉。

		- 支持多处理机系统

			- 但线程进程只能运行在一个处理机上，多线程进程可以分在多个处理机上执行

	- 什么是进程调度？常用的调度算法有哪些？

		- 进程调度定义

		- 常用算法

			- 先来先服务

			- 时间片轮转

			- 短作业优先

			- 优先级

			- 高响应比优先

			- 多级队列

			- 多级反馈队列

	- 什么是管道（pipe）？它可以用于哪些类型的进程通信？

		- 在Linux中，管道是一种使用非常频繁的通信机制。本质上说，管道是一种文件，但可以克服使用文件进行通信的两个问题：1. 限制管道的大小。 2. 读进程的工作速度可能比写进程快。

		- 管道只能由创建进程所访问，当父进程创建一个管道之后，由于管道是一种特殊文件，子进程会继承父进程的打开文件和管道，并用它来与父进程进行通信

	- 什么是消息队列（message queue）？它与管道有什么不同？

		- 进程间的数据交换以格式化的信息为单位。若通信的进程之间不存在可以直接访问的共享空间，则必须利用系统提供的发送消息和接收消息两个原语进行数据交换

			- 直接通信

			- 间接通信

		- 消息队列可以是单向或双向的，支持非亲缘关系的进程间通信，提供了消息的缓存和同步机制。

	- 什么是共享内存（shared memory）？它与消息队列和管道有何异同？

		- 在通信的进程之间存在一块可直接访问的共享空间，通过对这片空间进行读/写操作可以实现进程之间的信息交换

		- 异同点总结

			- 共享内存和消息队列： 都是通过内核提供的机制进行通信，可以用于非亲缘关系的进程间通信，提供了更灵活的数据传输方式

			- 管道： 主要用于相关进程之间的通信，是单向的，适用于简单数据传递。

	- 什么是信号（signal）？它用于什么场景？

	- 什么是套接字（socket）？它用于哪些类型的进程通信？

	- 进程间通信的机制有哪些优缺点？如何选择合适的通信机制？

		- 1. 管道（Pipe）：
		优点：
		简单，易于使用。
		可以实现单向或双向通信。
		缺点：
		只能用于具有父子关系的进程间通信。
		数据传输受到缓冲区大小的限制。
		只能实现单向或双向通信。
		2. 消息队列（Message Queue）：
		优点：
		异步通信，进程间解耦。
		提供消息缓冲，避免数据丢失。
		缺点：
		对消息的格式和大小有一定的限制。
		不适合频繁大量的数据传输。
		3. 共享内存（Shared Memory）：
		优点：
		高效，无需复制数据。
		适用于大量数据的频繁通信。
		缺点：
		需要同步机制，避免竞争条件。
		不适用于不同计算机间的通信。
		4. 信号量（Semaphore）：
		优点：
		用于进程间同步。
		可以用于多进程对共享资源的访问控制。
		缺点：
		不能传递数据，只能用于同步。

	- 什么是远程过程调用（RPC）？它与进程间通信有何异同？

	- 什么是异步编程？它如何实现并发和并行？

		- 定义

			- 异步编程是一种编写不会阻塞程序执行的代码的编程方式。在异步编程中，程序可以在执行某个任务时同时执行其他任务，而不必等待当前任务完成。这种方式允许程序在等待 I/O 操作、网络请求或其他可能导致阻塞的任务时继续执行其他任务，从而提高程序的并发性和响应性

		- 如何实现并发和并行

	- 什么是事件驱动编程（event-driven programming）？它与异步编程有何关系？

		- 事件驱动编程（Event-Driven Programming）是一种编程范式，其核心思想是程序的执行流程是由事件的发生和处理来驱动的。在事件驱动编程中，程序响应外部事件的发生，而不是按照预定的顺序顺序执行代码。事件可以是用户的输入、系统的消息、传感器的触发等。

		- 它与异步编程有何关系

- 线程

	- 线程的通信方式有哪些？分别是什么？

		- 锁机制

			- 互斥锁

			- 条件变量

			- 读写锁

		- 信号量机制（semaphore）

		- 信号机制（signal）

	- 线程的并发和并行有什么区别？

		- 并发

			- 指两个或多个事件在同一个时间段内发生，是由线程调度实现的。

		- 并行

			- 指两个或多个事件在同一时刻发生（同时发生）

	- 什么是条件变量？如何使用？

	- 线程和进程在性能和资源消耗方面的差异是什么？
		进程： 进程是独立的执行单元，每个进程都有自己独立的地址空间、文件描述符、系统数据等。因此，创建新进程的开销相对较大，因为需要为其分配独立的资源。进程之间的通信通常需要使用昂贵的进程间通信机制，例如管道、消息队列等。
		线程： 线程是进程内的执行单元，多个线程共享相同的地址空间和其他资源。因此，创建线程的开销较小，线程之间的通信更为直接，可以通过共享内存等轻量级的方式进行。
		切换开销：
		进程： 由于进程有独立的地址空间，进程切换的开销相对较大。进程切换涉及到上下文切换，需要保存和恢复整个进程的状态信息。
		线程： 线程切换的开销相对较小，因为线程共享相同的地址空间，切换时只需保存和恢复线程私有的寄存器和栈等信息。
		并发性：
		进程： 进程之间相对独立，一个进程的崩溃通常不会影响其他进程的执行。这提供了更好的健壮性，但也增加了进程间通信的复杂性。
		线程： 线程共享相同的地址空间，一个线程的错误可能会影响同一进程中的其他线程。但由于共享数据更为容易，线程之间的通信通常更简便。
		内存消耗：
		进程： 由于每个进程都有独立的地址空间，进程的内存消耗较大。
		线程： 由于线程共享相同的地址空间，线程的内存消耗相对较小。


	- 什么是线程局部存储？

	- 线程的栈和堆有什么区别？
	线程的堆和栈用于储存程序运行时的数据和变量。
	在多线程编程中，理解线程的栈（Stack）和堆（Heap）的区别是非常重要的，因为它们影响着数据的管理和线程的行为方式。以下是栈和堆的主要区别：
	### 栈（Stack）

	- **线程独有**：每个线程都有自己的栈空间，这个栈空间是线程私有的。栈用于存储局部变量、函数参数以及函数调用的上下文。当一个函数被调用时，一个新的栈帧（Stack Frame）被创建并压入调用线程的栈中，用于存储这个函数调用的局部变量和一些必要的信息。当函数调用结束时，对应的栈帧会被弹出栈。
	- **大小有限**：栈的大小通常有限，并且在线程创建时就已经确定。这意味着栈空间是有限的，过深的函数调用会导致栈溢出（Stack Overflow）。
	- **自动管理**：栈空间的分配和释放是自动进行的。函数调用时自动分配，函数返回时自动释放，无需程序员手动管理。
	- **访问速度快**：由于栈有严格的LIFO（Last In, First Out，后进先出）原则，访问速度很快，且其管理方式使得栈的分配和释放效率很高。

	### 堆（Heap）

	- **线程共享**：堆是所有线程共享的内存区域。不同线程可以访问和修改堆上的对象或数据，因此对堆上数据的访问需要适当的同步机制（如锁），以避免竞态条件或数据不一致。
	- **动态分配**：堆空间用于存储动态分配的内存。程序员需要显式地分配和释放这部分内存（如使用`new`、`delete`关键字在C++中，或使用`malloc`、`free`函数在C中）。在一些高级语言中，如Java或Python，垃圾收集器会自动管理堆内存的分配和释放。
	- **大小相对较大**：堆的大小通常远大于栈的大小，它受限于计算机系统中的可用物理内存和操作系统的限制，可以动态地扩展。
	- **访问速度相对较慢**：相比于栈，堆的访问速度较慢，且由于需要手动管理，还可能引发内存泄露和内存碎片等问题。

	总之，栈和堆是线程中用于存储数据的两个不同的内存区域，它们各有特点和用途。栈主要用于存储执行线程的局部变量和调用上下文，而堆则用于存储程序运行时动态分配的数据。正确理解和使用栈和堆对于编写高效、可靠的多线程程序至关重要。


	- 什么是用户线程和内核线程？它们的区别是什么？

		- 用户线程：有关线程管理的所有工作都由应用程序在用户空间内完成，内核意识不到线程的存在。调度单位是进程，各个进程轮流执行一个时间片。

		- 内核线程：内核级线程同样也是在内核的支持下运行的，线程管理的所有工作都是在内核空间内实现的，内核空间为每个内核级线程设置一个线程控制块，内核根据控制块感知线程的存在，对其加以控制。

		- 区别：内核线程可以同时调度统一进程中的多个线程并行执行，如果其中一个线程被阻塞，系统内的所有线程都会被阻塞，并且内核分配给他的只有一个CPU，不能发挥多处理机的优势。而内核级线程可以调度其他线程占用处理机，或者运行其他进程中的线程。用户级线程的切换不用转到内核空间，节省了模式切换的开销，而内核级线程的切换需要从用户态转到核心态进行，系统开销较大。

	- 什么是协程？如何实现协程？
		什么是协程？
		协程（Coroutine）是一种程序组件，用于协作式的多任务处理，它比线程更加轻量级。协程允许执行被挂起（暂停）和恢复（继续）的点在特定位置，非常适合执行异步操作和处理并发任务，而不需要多线程的复杂性和开销。与线程相比，协程的一个关键区别是它们的调度通常是由程序员显式控制的，而不是由操作系统的调度器控制。

		协程的优点
		高效性：协程因为减少了线程上下文切换的成本，通常比线程更加高效。
		简化异步编程：协程通过挂起和恢复执行的能力，简化了异步编程模型，使异步代码的编写和理解更接近同步代码。
		减少资源消耗：协程在单线程内执行，减少了线程创建和销毁的资源消耗

	- 什么是读写锁？如何使用？
		读写锁（Read-Write Lock），也称为共享-独占锁，是一种同步机制，用于解决多线程环境下对共享资源的访问控制问题。读写锁允许并发的读访问共享资源，但对写访问是独占的。这意味着：
		当没有线程写入共享资源时，多个线程可以同时读取共享资源。
		当一个线程正在写入共享资源时，其他线程既不能读取也不能写入。
		读写锁优于互斥锁（Mutex）的地方在于，它允许对共享资源的更高并发度，尤其是在读操作远多于写操作时，可以显著提高性能。

	- 线程的优缺点是什么？
		- 优点
			- 并发执行： 线程使得程序能够同时执行多个任务，提高了程序的并发性，更有效地利用多核处理器的性能。
			  资源共享： 线程可以共享相同进程的地址空间，使得数据和资源的共享更为方便，减少了进程间通信的开销。
			  轻量级： 相对于进程，线程的创建和切换开销较小。线程之间的通信和同步更为直接，不需要使用进程间通信机制。
			  响应性： 线程可以用于实现对用户输入的快速响应，使得程序能够在后台执行任务同时响应用户的操作。
			  任务分解： 将任务分解成多个线程可以更容易地实现任务的并行执行，提高程序的执行效率。

		- 缺点
			- 争条件： 多个线程共享相同的数据和资源，容易出现竞争条件，需要额外的同步机制（如互斥锁、信号量）来避免。
			  死锁： 当多个线程相互等待对方释放资源时，可能发生死锁。设计并发程序时需要小心避免死锁的发生。
			  调试困难： 多线程程序的调试较为复杂，由于线程的并发性，可能产生难以重现和定位的 bug。
			  资源消耗： 每个线程都需要额外的内存和系统资源来维护其状态和上下文，大量线程的创建可能导致系统资源耗尽。
			  复杂性： 多线程编程相对于单线程编程更为复杂，需要考虑同步、线程安全、死锁等问题，增加了程序设计和维护的难度

	- 线程同步的方式有哪些？
		（1）临界区 CriticalSection：在任意时刻只允许一个线程对共享资源进行访问，如果有多个线程试图访问公共资源，那么在有一个线程进入后，其他试图访问公共资源的线程将被挂起，并一直等到进入临界区的线程离开，临界区在被释放后，其他线程才可以抢占。

		（2）互斥量 Mutex：采用互斥对象机制。只有拥有互斥对象的线程才有访问公共资源的权限，因为互斥对象只有一个，所以能保证公共资源不会同时被多个线程访问。当前拥有互斥对象的线程处理完任务后必须将线程交出，以便其他线程访问该资源。互斥对象和临界区对象非常相似，但是互斥量允许在进程间使用，而临界区只限制于同一进程的各个线程之间使用，但是更节省资源，更有效率。

		（3）信号量 semophore：信号量其实就是一个计数器，限制了同一时刻访问同一资源的最大线程数。如果这个计数达到了零，则所有对这个Semaphore类对象所控制的资源的访问尝试都被放入到一个队列中等待，直到超时或计数值不为零为止。

		（4）事件 Event，wait/notify：事件机制，允许一个线程在处理完一个任务后，主动唤醒另一个线程执行任务，通过通知操作的方式来保持线程的同步。

	- 什么是上下文切换？

		切换CPU到另一个进程需要保存当前进程状态并恢复到另外一个进程的状态。上下文是指某一时刻CPU寄存器和程序计数器的内容。进行上下文切换时，程序会讲旧进程的状态保存至PCB中，然后加载经调度而要执行的新进程的上下文。上下文切换只需要改变当前寄存器组的指针，并且在内核态下发生。

	- 什么是共享内存？如何实现线程间的共享内存？

		多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。它是针对其他进程间通信方式运行效率低而专门设计的。

	- 什么是读写锁？请介绍读写锁的概念、类型、操作以及使用场景。
		读写锁（Read-Write Lock），也称为共享-独占锁（Shared-Exclusive Lock），是一种同步机制，用于控制对共享资源的访问，以解决多线程程序中的并发问题。读写锁允许并发的读访问共享资源，但写访问则是互斥的。这意味着任何时候都可以有多个读者（reader）对共享资源进行读操作，但写者（writer）执行写操作时，必须独占访问权。

		### 类型

		读写锁主要有两种类型的操作：

		- **读锁（Shared Lock）**：允许多个线程同时获得读锁，进行读操作。当至少有一个线程持有读锁时，写操作将被阻塞。
		- **写锁（Exclusive Lock）**：只允许一个线程获得写锁，进行写操作。当有线程持有写锁时，其他线程的读操作和写操作都会被阻塞。

		### 操作

		读写锁的基本操作包括：

		- **加锁**：
		- **读加锁**：如果没有线程持有写锁，线程可以获得读锁。
		- **写加锁**：只有当没有线程持有读锁或写锁时，线程才能获得写锁。
		- **解锁**：持锁的线程完成操作后，应释放其持有的锁，以允许其他线程访问资源。

		### 使用场景

		读写锁非常适合读多写少的场景，其中对共享资源的读操作远远多于写操作。使用读写锁可以大幅提高这种场景下的并发性能，因为它允许多个读操作同时进行，只在写操作发生时才限制并发。典型的应用场景包括缓存系统、数据库管理系统等。

		### 如何使用

		不同的编程语言提供了不同的库和机制来实现读写锁。以下是一些示例：

		#### C++ (std::shared_mutex)

		C++17引入了`std::shared_mutex`，允许多个线程共享读锁，但写锁是独占的。

		```cpp
		#include <shared_mutex>
		#include <mutex>
		#include <iostream>

		std::shared_mutex rwLock;

		void readFunction() {
			std::shared_lock<std::shared_mutex> lock(rwLock);
			// 执行读操作
		}

		void writeFunction() {
			std::unique_lock<std::shared_mutex> lock(rwLock);
			// 执行写操作
		}
		```

		#### Python (threading模块)

		Python的`threading`模块提供了`Lock`和`RLock`，但没有直接的读写锁实现。可以使用`threading`模块的其他组件手动实现，或使用`concurrent.futures`等高级抽象。

		### 注意事项

		- **死锁**：不当使用读写锁可能导致死锁，例如，一个线程尝试在持有读锁的同时获得写锁。
		- **优先级**：读写锁的实现可能导致写饥饿问题，即写线程在高负载的读操作下长时间得不到服务。解决这个问题的一种方法是引入写优先的读写锁。

	- 什么是活锁？如何避免活锁？

		- 活锁通常发生在各个执行单元争夺资源的过程中，它们在互相等待对方释放资源，但由于某种原因，它们一直无法向前推进。与死锁不同，活锁中的执行单元仍在不断尝试，但一直无法取得进展。

		- 引入随机性、协商策略、回退策略

	- 什么是阻塞和非阻塞？请分别介绍阻塞和非阻塞的概念、优缺点以及使用场景。

		- 阻塞

			- 阻塞是指调用某个函数或操作时，如果该操作不能立即完成，调用者将被挂起（阻塞），直到操作完成为止。

			- 适用于一些简单的、同步的场景，当操作不会引起太长时间的等待时。

		- 非阻塞

			- 非阻塞是指调用某个函数或操作时，如果该操作不能立即完成，调用者不会被挂起，而是立即返回，可以继续执行其他操作。

			- 适用于需要保持系统响应性的场景，例如网络通信、GUI应用等，可以在等待某个事件的同时执行其他任务。

	- 什么是同步和异步？请分别介绍同步和异步的概念、优缺点以及使用场景。
		(1)概念：同步是指一个任务A完成需要依赖任务B时，只有等待任务B完成后，任务A才能完成任务。异步的概念与同步相对，任务A虽然需要依赖任务B完成任务，但其只是通知任务B需要完成什么工作，并不需要等待B完成任务，任务A指需完成自己的任务部分即可。
		(2)优缺点：异步执行效率优于同步，但同步比异步执行结果更加可靠。
		(3)使用场景：异步适合有大量I/O操作，如网络请求、文件操作等场景，可以避免阻塞主线程，提高程序性能。高并发应用，如Web服务器处理数百个并发请求时使用异步I/O模型。同步适合涉及顺序性强、逻辑简单的操作，例如配置文件的读取。需要立即得到操作结果的情况。
		

### 内存管理

- 什么是虚拟内存？它的实现原理和作用是什么？

	- 什么是虚拟内存？

		- 程序不需要全部装入内存来运行，运行时动态的调入数据，若内存不够，再换出一些数据

	- 它的实现原理和作用是什么？

		- 原理

			- 时间局部性

			- 空间局部性

			- 高速缓存技术

		- 作用

			- 解决了传统内存管理方式一次性和驻留性的缺点，使用户看到的内存远远大于实际内存

- 内存管理中的分页和分段有什么区别？分页的页表如何设计？如何处理页表中的访问异常？

	- 内存管理中的分页和分段有什么区别？

		- 分页对用户不可见，分段对用户可见

		- 分页的地址空间是一维的，分段的地址空间是二维的（分段需要给出段号和段内地址才能找到内存块在内存中的位置）

		- 分段更容易实现内存的共享和保护（纯代码，可重入代码可以共享）

		- 分段、和单机页表都需要两次访存，但是分段也可以引入快表机构

		- 分段要检查段号和段内地址是否越界，分页只用检查页号是否越界，因为段长是人为规定的，页长是固定的

	- 分页的页表如何设计？

		- 页表项大小： 页表中的每个项存储一个虚拟页面到物理页面的映射关系。页表项的大小会影响到页表的大小和访问速度。较小的页表项可能导致页表变得较大，但可以减小内存的占用。较大的页表项可以减小页表的大小，但可能会导致访问速度较慢。
		页表的层次结构： 为了减小页表的大小，可以使用多级页表的层次结构。这样可以将虚拟地址划分为不同的层级，每个层级对应一个级页表。这样的结构可以在不需要完整页表的情况下，只加载部分页表。
		全局页表： 对于多进程系统，使用全局页表可以在所有进程之间共享物理内存的映射，从而节省内存。每个进程仍有自己的虚拟地址空间，但物
		TLB（Translation Lookaside Buffer）： TLB是一个缓存，存储了一部分最近访问的虚拟页到物理页的映射，以加速地址转换。设计时需要考虑如何管理TLB的一致性和替换策略。
		页表的存储位置： 页表可以存储在内存中，也可以存储在硬盘上。存储在内存中的页表可提高访问速度，但会占用更多内存。存储在硬盘上的页表则需要在需要时加载到内存中，因此可能引入较大的访问延迟。

	- 如何处理页表中的访问异常？

- 什么是缺页中断？如何处理缺页中断？

	- 缺页中断是因为当前执行的指令想要访问的目标页面未调入内存而产生的，属于内中断，可以被系统处理

	- 缺页进程阻塞如果内存满了，没有空闲块，则需要进行页面置换，如果没满，则直接从外存将页面读入内存的操作，启动I/O进行页面读入的操作，修改页表，并且更新快表

- 什么是分段存储管理？分段存储管理的优缺点是什么？

	- 什么是分段存储管理？

		- 将逻辑地址空间按照自身逻辑关系分为若干个段，每段从0开始编址，每个段在内存中占连续内存空间，各段之间不可相邻

	- 分段存储管理的优缺点是什么？

		- 分段是按照逻辑模块来划分的，容易实现信息的共享和保护，如果段很长的话，需要分配很长很大的逻辑空间，不方便。另外，分段存储管理可能会产生很多外部碎片。

- 什么是内存映射？内存映射的作用是什么？在哪些情况下会用到内存映射？

	- 进程可以使用系统调用，请求操作系统将文件映射到进程的虚拟地址空间，以访问内存的方式读写文件，进程关闭时，操作系统负责将文件数据写回磁盘，并且解除内存映射。多个进程可以映射同一个文件，方便共享

	- 无需使用标准的读取或写入文件的系统调用，这样的直接内存访问可以提高文件的读写性能。 多个进程可以将同一个文件映射到它们各自的地址空间，实现共享内存的目的。这样的共享内存机制使得多个进程可以方便地进行数据交换，而无需通过进程间通信（IPC）的方式。

	- 文件I/O操作，共享内存（无需通过进程间通信交换数据），数据库系统

- 什么是交换空间？交换空间的作用是什么？如何设置交换空间？

	- 交换空间将当前未活动的内存页或段交换出物理内存（RAM）并暂时存储在磁盘上，以便给活跃的进程提供更多的物理内存空间。

	- 扩展内存： 通过使用交换空间，系统可以在物理内存不足时，暂时将不活跃的数据从RAM移到磁盘上，以扩展可用的内存空间。
多任务处理： 允许系统同时运行多个进程，即使它们的总内存需求超过了物理内存的容量。
性能提升： 通过交换不活跃的部分到磁盘，可以为当前活跃的进程提供更多的物理内存，从而提高系统的整体性能。

	- 如何设置交换空间

- 什么是段页式存储管理？段页式存储管理的优缺点是什么？

	- 什么是段页式存储管理？

		- 将地址空间按照逻辑关系分为一个个段，然后再将各段划分成大小相等的页面，再将内存空间划分为页面大小相等的内存块，系统以页面为单位进行内存分配，逻辑地址 = 段号 + 页号 + 页内偏移量

	- 段页式存储管理的优缺点是什么？

		- 按照逻辑模块来划分，容易实现信息的共享与保护，同时不容易产生很多外部碎片

- 什么是物理地址和逻辑地址？它们之间的关系是什么？

	- 物理地址

		- 物理地址是资源在内存上的实际地址

	- 逻辑地址

		- 相对于进程的起始地址而言的地址，又称虚拟地址，每个进程都有一套自己的逻辑地址。

	- 关系

		- 操作系统通过页表和段表将逻辑地址映射到物理地址，在程序执行过程中，CPU生成逻辑地址，然后OS将逻辑地址映射到物理地址

- 什么是快表？快表的作用是什么？如何实现快表？

	- 什么是快表？

		- 快表（TLB）是一种访问速度比内存快很多的高速缓存（cache)，专门用于访问页表项

	- 快表的作用是什么？

		- 通过将最近用到的页表放入cache中，加速地址的变换，由于局部性原理，可能会多次查到同一个页表项

	- 如何实现快表？

		- 子主题 1

- 什么是写时复制技术？写时复制技术的原理是什么？在哪些情况下会用到写时复制技术？

### 设备驱动与文件系统

- 什么是缓存？缓存如何提高系统的性能？

	- 缓存是一种临时存储的机制，用于存储先前访问过的数据，以便将来的访问能够更快速地获取这些数据。缓存的目标是通过提供快速的访问来改善系统性能，避免重复计算或数据读取的开销。

- 什么是文件系统？文件系统的组成部分有哪些？

	- 文件系统是计算机系统中用于组织和管理文件的一组规则和数据结构。它定义了文件和目录的存储方式、命名规则、权限控制等，并提供了对这些文件和目录的访问接口。文件系统通常运行在操作系统的支持下，为用户和应用程序提供了方便的文件管理和访问机制。

	- 文件： 文件是数据的逻辑单元，可以是文本文件、图像、音频、视频等。文件系统负责存储、组织和管理这些文件。
目录： 目录是用于组织文件的容器，它可以包含文件和其他子目录。目录通过树状结构的形式来组织文件系统的层次结构。
文件描述符/索引节点： 文件系统为每个文件维护一个文件描述符或索引节点，其中包含有关文件的元数据信息，如文件大小、所有者、权限、创建时间和修改时间等。
数据块： 文件系统将文件的实际数据存储在称为数据块的物理存储单元中。这些数据块通常位于存储设备上，例如硬盘驱动器或固态硬盘。
文件路径： 文件路径是指定文件或目录在文件系统中位置的一种方式。它可以是绝对路径（从根目录开始的完整路径）或相对路径（相对于当前工作目录的路径）。
权限和访问控制： 文件系统定义了文件和目录的访问权限，以控制哪些用户或进程可以执行读、写、执行等操作。
文件系统操作接口： 提供了一组系统调用或命令，允许用户和应用程序执行文件和目录的创建、删除、复制、移动等操作。
日志（可选）： 一些文件系统支持事务日志，记录文件系统的变更操作，以便在系统崩溃时进行恢复，并确保文件系统的一致性。

- 什么是文件描述符？文件描述符的作用是什么？

	- 打开文件时，并不会把文件数据直接写入内存中，而是将目录项中的信息复制到内存中的打开文件表中，并将打开文件表的索引号（文件描述符）返回给用户

	- 用户可以通过文件描述符来查询打开文件表来直接操作自己的文件而不再需要每次都查询目录

	- 在读/写文件时，使用文件描述符即可指明文件而不再需要用到文件名

## 重点内容

### 进程与线程管理，关系高并发编程

### 内存管理也是重点

